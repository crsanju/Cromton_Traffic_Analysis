
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traffic Analysis Dashboard V8 - Updated Queue Logic</title>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg: #f6f3ef;
            --ink: #1c1c1c;
            --muted: #5f5f5f;
            --card: #ffffff;
            --line: #e1ded8;
            --brand: #1f5e63;
            --brand-2: #0f2f32;
            --accent: #d36b2c;
            --shadow: 0 12px 30px rgba(0, 0, 0, 0.08);
        }

        * { box-sizing: border-box; }
        body {
            font-family: "Space Grotesk", "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande", "Lucida Sans", sans-serif;
            background: radial-gradient(1200px 600px at 10% -10%, #e8f0ef 0%, transparent 55%),
                        radial-gradient(1200px 600px at 100% -10%, #f3e7dc 0%, transparent 50%),
                        var(--bg);
            color: var(--ink);
            margin: 0;
            padding: 24px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--card);
            padding: 24px;
            border-radius: 16px;
            box-shadow: var(--shadow);
            border: 1px solid var(--line);
        }
        h1 {
            text-align: center;
            color: var(--brand-2);
            letter-spacing: 0.5px;
            margin: 10px 0 24px;
        }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 22px; }
        .stack { display: flex; flex-direction: column; gap: 22px; }
        .card {
            background: var(--card);
            padding: 18px;
            border-radius: 12px;
            border: 1px solid var(--line);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.05);
            margin-bottom: 0;
        }
        .card h3 {
            margin: 0 0 12px;
            color: var(--brand-2);
            border-bottom: 2px solid var(--brand);
            padding-bottom: 10px;
        }
        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 700;
            font-size: 0.9em;
            color: var(--muted);
        }
        select, input {
            width: 100%;
            padding: 10px 12px;
            margin-bottom: 12px;
            border: 1px solid var(--line);
            border-radius: 8px;
            background: #fbfbfa;
            color: var(--ink);
        }
        select:focus, input:focus { outline: 2px solid rgba(31, 94, 99, 0.2); border-color: var(--brand); }
        button {
            background-color: var(--brand);
            color: white;
            padding: 11px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            font-size: 16px;
            font-weight: 700;
            letter-spacing: 0.2px;
        }
        button:hover { background-color: #174a4e; }
        
        table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 0.9em; }
        th, td { border: 1px solid var(--line); padding: 8px; text-align: center; }
        th { background-color: var(--brand); color: white; }
        
        .summary-table th { background-color: #2d3a3b; color: #fff; }
        .summary-table td { font-weight: bold; }
        .row-header { text-align: left; background-color: #f0ebe5; }

        .status-green { background-color: #d4edda; color: #155724; }
        .status-yellow { background-color: #fff3cd; color: #856404; }
        .status-red { background-color: #f8d7da; color: #721c24; }
        
        .hidden { display: none; }
        .params-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        .year-calc-info { background-color: #e2e3e5; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 0.9em; }
        .data-table { max-height: 400px; overflow-y: auto; }
        .data-table table { font-size: 0.85em; }
        .data-table th { position: sticky; top: 0; z-index: 1; }
        
        #map { height: 400px; width: 100%; border-radius: 10px; border: 2px solid var(--brand); }
        .map-info { margin-top: 10px; padding: 10px; background: #eef4f3; border-radius: 8px; font-size: 0.9em; }
        .site-id-label {
            background: rgba(255,255,255,0.95);
            border: 1px solid #0056b3;
            color: #003b73;
            font-size: 10px;
            font-weight: 700;
            padding: 1px 4px;
            border-radius: 3px;
            box-shadow: none;
            pointer-events: none;
        }

        /* Tab Navigation Styles */
        .tab-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            border-bottom: 2px solid var(--line);
            margin-bottom: 20px;
            padding-bottom: 8px;
        }
        .tab-button {
            background-color: #f1eeea;
            border: 1px solid var(--line);
            outline: none;
            cursor: pointer;
            padding: 10px 18px;
            transition: 0.2s;
            font-size: 15px;
            font-weight: 700;
            color: var(--muted);
            border-radius: 999px;
        }
        .tab-button:hover { background-color: #e9e4dd; }
        .tab-button.active { background-color: var(--brand); color: white; border-color: var(--brand); }
        .tab-content { display: none; animation: fadeEffect 0.2s; }
        .tab-content.active { display: block; }
        @keyframes fadeEffect { from {opacity: 0;} to {opacity: 1;} }

        /* Loader for GeoJSON */
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #0056b3; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; display: inline-block; vertical-align: middle; margin-left: 10px; }

        /* LOS Colors */
        .los-a { background-color: #00eb00; color: black; }
        .los-b { background-color: #92d050; color: black; }
        .los-c { background-color: #ffff00; color: black; }
        .los-d { background-color: #ffc000; color: black; }
        .los-e { background-color: #e26b0a; color: white; }
        .los-f { background-color: #c00000; color: white; }
        
        /* Loading Indicator */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .loading-content {
            background: white;
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 10px 28px rgba(0,0,0,0.25);
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0056b3;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            font-size: 18px;
            color: #0056b3;
            font-weight: bold;
        }
        .loading-subtext {
            font-size: 14px;
            color: #666;
            margin-top: 10px;
        }

        /* Smart Search Landing Page Styles */
        .landing-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1f5e63 0%, #15373a 100%);
            z-index: 10000;
            display: flex; justify-content: center; align-items: center;
            color: white;
            transition: opacity 0.5s;
        }
        .landing-content {
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(10px);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 12px 36px rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        .landing-content h1 { color: white; margin-bottom: 10px; font-size: 2.5em; }
        .landing-content p { color: #e0e0e0; margin-bottom: 30px; font-size: 1.1em; }

        .search-box-container {
            display: flex; gap: 10px; margin-bottom: 20px;
        }
        .search-box-container input {
            flex-grow: 1; padding: 15px; border: none; border-radius: 5px;
            font-size: 16px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .search-box-container button {
            width: auto; padding: 0 30px; background: #f4c35e; color: #1f2b2c;
        }
        .search-box-container button:hover { background: #e0b24f; }

        .quick-actions { display: flex; gap: 15px; justify-content: center; margin-top: 20px;}
        .action-btn { padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 14px; border: none; transition: 0.2s; }
        .action-btn.secondary { background: rgba(255,255,255,0.2); color: white; }
        .action-btn.secondary:hover { background: rgba(255,255,255,0.3); }
        .action-btn.outline { background: transparent; border: 1px solid rgba(255,255,255,0.5); color: white; }
        .action-btn.outline:hover { background: rgba(255,255,255,0.1); }

        .search-status { margin-top: 15px; height: 20px; font-size: 0.9em; color: #f4c35e; }
        .hidden-overlay { opacity: 0; pointer-events: none; }

        #mismatchPanel .landing-content {
            color: #1c1c1c;
        }

        #mismatchPanel label {
            color: #1c1c1c;
        }

        #mismatchPanel input {
            background: #ffffff;
            color: #1c1c1c;
        }

        .map-link { color: var(--brand-2); text-decoration: none; font-weight: 700; }
        .map-link:hover { text-decoration: underline; }

        .container-flex { display: grid; grid-template-columns: 1fr 1fr; gap: 22px; }
        .panel-side, .panel-main { width: 100%; }

        @media (max-width: 1100px) {
            .grid, .container-flex { grid-template-columns: 1fr; }
            .tab-button { width: 100%; justify-content: center; }
        }
    </style>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
<body>

<div id="landingPage" class="landing-overlay">
    <div class="landing-content">
        <h1>Crompton Traffic Analysis </h1>
        <p>Enter a location to automatically find the nearest traffic data point.</p>
        
        <div class="search-box-container">
            <input type="text" id="landingSearchInput" placeholder="Enter address, suburb, or lat,long..." onkeypress="handleEnter(event)">
            <button onclick="executeSmartSearch()">Search Location</button>
        </div>
        
        <div class="quick-actions">
            <button class="action-btn secondary" onclick="useCurrentLocation()">üìç Use My Location</button>
            <button class="action-btn outline" onclick="closeLandingPage()">Browse Dashboard Manually</button>
        </div>

        <div id="searchStatus" class="search-status"></div>
    </div>
</div>

<div id="mismatchPanel" class="landing-overlay hidden-overlay">
    <div class="landing-content">
        <h1>Road Not In Database</h1>
        <p id="mismatchSummary">We could not find this road in the database.</p>

        <div class="params-grid" style="grid-template-columns: 1fr 1fr; gap: 12px; text-align: left;">
            <div>
                <label for="mismatchPercent">Percent of known road volume (%)</label>
                <input type="number" id="mismatchPercent" value="100" min="0" step="1">
            </div>
            <div>
                <label for="mismatchHouseholds">Total number of households</label>
                <input type="number" id="mismatchHouseholds" value="0" min="0" step="1">
            </div>
        </div>

        <div class="search-status" id="mismatchResult"></div>

        <div class="quick-actions">
            <button class="action-btn secondary" onclick="applyMismatchInputs()">Use Custom TIA</button>
            <button class="action-btn outline" onclick="closeMismatchPanel()">Cancel</button>
        </div>
    </div>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay">
    <div class="loading-content">
        <div class="spinner"></div>
        <div class="loading-text">Loading Traffic Data...</div>
        <div class="loading-subtext">Fetching data from GitHub</div>
    </div>
</div>

<div class="container">
    <h1>Traffic Analysis Dashboard</h1>
    
    <div class="tab-bar">
        <button class="tab-button active" onclick="openTab(event, 'tab-hourly')">TMR Roads</button>
        <button class="tab-button" onclick="openTab(event, 'tab-aadt')">Custom TIA</button>
        <button class="tab-button" onclick="openTab(event, 'tab-tia')">Gold coast</button>
        <button class="tab-button" onclick="openTab(event, 'tab-toowoomba')">Toowoomba</button>
        <button class="tab-button" onclick="openTab(event, 'Ipswich')">Ipswich Analysis</button>
        <button class="tab-button" onclick="openTab(event, 'Logan')">Logan Analysis</button>
    </div>

    <div id="tab-hourly" class="tab-content active">
    <div class="grid">
        <div class="stack">
            <div class="card">
                <h3>1. Select Site</h3>
                <label for="siteSelect">Search Site ID or Name:</label>
                <input list="sites" id="siteInput" placeholder="Type to search or click a marker on the map...">
                <datalist id="sites"></datalist>
                <p style="font-size: 0.85em; color: #666; margin-top: 5px;">
                    üí° <strong>Tip:</strong> Type a site ID/name above OR click any marker on the map below
                </p>
                <div id="siteInfo" class="hidden">
                    <p><strong>Road:</strong> <span id="roadName"></span></p>
                    <p><strong>Description:</strong> <span id="siteDesc"></span></p>
                </div>
            </div>
        </div>

        <div id="mapSection" class="card">
            <h3>2. Site Location</h3>
            <p id="tmrMapCount" style="font-size:0.85em; color:#555; margin: 0 0 8px 0;">Showing 0 of 0 sites</p>
            <div id="map"></div>
            <div class="map-info">
                <p><strong>Coordinates:</strong> <span id="mapCoords">-</span></p>
                <a id="mapLink" href="#" target="_blank" class="map-link">üìç View on Google Maps</a>
            </div>
        </div>
    </div>

    <!-- Raw Data Table -->
    <div id="rawDataSection" class="hidden">
        <div class="card">
            <h3>3. Site Traffic Data (Weekday Average by Hour)</h3>
            <div class="data-table">
                <table id="rawDataTable">
                    <thead>
                        <tr>
                            <th>Hour</th>
                            <th>GAZETTAL</th>
                            <th>AGAINST GAZETTAL</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <div class="card">
        <h3>4. Analysis Parameters</h3>
        <div class="year-calc-info">
            <strong>Year Calculation:</strong> Growth applied for <strong><span id="calcYears">0</span> years</strong>.
        </div>
        <div class="params-grid">
            <div><label>Data Year:</label><input type="number" id="dataYear" value="2020" step="1" onchange="updateYears()"></div>
            <div><label>Opening Year:</label><input type="number" id="openingYear" value="2026" step="1" onchange="updateYears()"></div>
            <div><label>Growth (%):</label><input type="number" id="growthRate" value="3.0" step="0.1"></div>
            <div><label>HV (%):</label><input type="number" id="hvPercent" value="7.0" step="0.1"></div>
        </div>
        
        <div class="params-grid" style="margin-top:10px; border-top: 1px solid #ddd; padding-top:10px;">
            <div style="grid-column: span 2;">
                <label>Road Type (Auto-Cap):</label>
                <select id="roadType" onchange="updateAutoCapacity()">
                    <option value="">-- Select Road Type --</option>
                    <option value="freeway">Freeway (100km/h+)</option>
                    <option value="highway">Multi-lane Highway</option>
                    <option value="arterial_high">High-Quality Arterial</option>
                    <option value="arterial_urban">Typical Urban Arterial</option>
                    <option value="signals">Signalised Intersection (Peak)</option>
                </select>
            </div>
            <div><label>AADT (Optional):</label><input type="number" id="manualAadt" placeholder="Enter AADT"></div>
            <div><label>K-Factor (%):</label><input type="number" id="kFactor" value="10" step="0.5"></div>
        </div>

        <div class="params-grid">
            <div><label>Lanes (Dir):</label><input type="number" id="lanes" value="2" step="1"></div>
            <div><label>Cap/Ln:</label><input type="number" id="capacity" value="2200" step="50"></div>
            <div style="grid-column: span 2;"><label>Directional Split (D%):</label><input type="number" id="dSplit" value="60" step="1"></div>
        </div>
        <button onclick="calculate()">Calculate Analysis</button>
    </div>

    <div id="results" class="hidden">
        
        <!-- Summary Table -->
        <div class="card">
            <h3>5. Executive Summary (VCR & LOS) - <span id="displayYear"></span></h3>
            <table class="summary-table" id="summaryTable">
                <thead>
                    <tr>
                        <th>Scenario</th>
                        <th>AM</th>
                        <th>OP</th>
                        <th>PM</th>
                        <th>EV</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>

        <div class="card">
            <h3>5. Traffic Profile (Hourly)</h3>
            <canvas id="trafficChart" height="80"></canvas>
        </div>

        <div class="grid">
            <!-- Gazettal -->
            <div class="card">
                <h3>7. Gazettal Direction (Detailed)</h3>
                <div id="gazettal-content">No data</div>
                <div id="gazettal-queue" class="hidden">
                    <h4>Queue Estimation (Per Lane)</h4>
                    <p><small>Based on Future Peak 5-min Vol/Lane: LV=<span id="lvGaz"></span>, HV=<span id="hvGaz"></span> (Total/Ln: <span id="totGaz"></span>)</small></p>
                    <table class="detail-table">
                        <thead><tr><th>Duration</th><th>LV Factor</th><th>HV Factor</th><th>Queue (m)</th></tr></thead>
                        <tbody id="blockageTableGaz"></tbody>
                    </table>
                </div>
            </div>

            <!-- Against Gazettal -->
            <div class="card">
                <h3>8. Against Gazettal Direction (Detailed)</h3>
                <div id="against-content">No data</div>
                <div id="against-queue" class="hidden">
                    <h4>Queue Estimation (Per Lane)</h4>
                    <p><small>Based on Future Peak 5-min Vol/Lane: LV=<span id="lvAg"></span>, HV=<span id="hvAg"></span> (Total/Ln: <span id="totAg"></span>)</small></p>
                    <table class="detail-table">
                        <thead><tr><th>Duration</th><th>LV Factor</th><th>HV Factor</th><th>Queue (m)</th></tr></thead>
                        <tbody id="blockageTableAg"></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    </div>

    <div id="tab-aadt" class="tab-content">
        <div class="grid">
            <div class="card">
                <h3>AADT Inputs</h3>
                <div class="params-grid">
                    <div><label>Current AADT:</label><input type="number" id="aadt_val" placeholder="e.g. 15000"></div>
                    <div><label>Data Year:</label><input type="number" id="aadt_year_data" value="2024"></div>
                    <div><label>Project Year:</label><input type="number" id="aadt_year_proj" value="2031"></div>
                    <div><label>Growth (% p.a):</label><input type="number" id="aadt_growth" value="3.0" step="0.1"></div>
                    <div><label>HV (%):</label><input type="number" id="aadt_hv" value="5.0" step="0.5"></div>
                </div>
                <div class="params-grid" style="margin-top:10px; border-top:1px solid #ddd; padding-top:10px;">
                    <div style="grid-column: span 2;">
                        <label>Road Type:</label>
                        <select id="aadt_road_type" onchange="updateAadtCap()">
                            <option value="2100">Freeway (100km/h)</option>
                            <option value="1800">Highway (Multi-lane)</option>
                            <option value="1400">Arterial (Major)</option>
                            <option value="1000">Urban Street (Signals)</option>
                        </select>
                    </div>
                    <div><label>Lanes (1 Dir):</label><input type="number" id="aadt_lanes" value="2"></div>
                    <div><label>Cap/Ln:</label><input type="number" id="aadt_cap" value="1800"></div>
                </div>
                <div class="params-grid" style="margin-top:10px; border-top:1px solid #ddd; padding-top:10px;">
                    <div><label>K-Factor (%):</label><input type="number" id="aadt_k" value="10" title="% of AADT in Peak Hour"></div>
                    <div><label>Dir Split (%):</label><input type="number" id="aadt_d" value="60" title="% in Peak Direction"></div>
                </div>
                <button onclick="calculateAADTLogic()" style="margin-top:15px; width:100%; background:#28a745;">Calculate AADT Scenarios</button>
            </div>

            <div class="card">
                <h3>Performance Results (Peak Hour)</h3>
                <table style="width:100%; border-collapse: collapse;">
                    <tr style="background:#eee; text-align:left;">
                        <th style="padding:8px;">Metric</th>
                        <th style="padding:8px;">Value</th>
                    </tr>
                    <tr><td style="padding:8px;">Future AADT</td><td style="padding:8px;" id="res_fut_aadt">-</td></tr>
                    <tr><td style="padding:8px;">Design Hr Vol (DHV)</td><td style="padding:8px; font-weight:bold;" id="res_dhv">-</td></tr>
                    <tr><td style="padding:8px;">Volume / Capacity (v/c)</td><td style="padding:8px;" id="res_vc">-</td></tr>
                    <tr><td style="padding:8px;">Level of Service</td><td style="padding:8px; font-weight:bold;" id="res_los">-</td></tr>
                </table>
                
                <h4 style="margin-top:20px; border-bottom: 2px solid #dc3545;">Queue Estimation (Blockage)</h4>
                <p style="font-size:0.9em; color:#666;">Estimated queue length if traffic is blocked for X minutes during peak.</p>
                <table class="data-table">
                    <thead>
                        <tr>
                            <th>Blockage Duration</th>
                            <th>Queue Length (m)</th>
                        </tr>
                    </thead>
                    <tbody id="aadt_queue_table">
                        <tr><td colspan="2">Run calculation...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="tab-tia" class="tab-content">
        <div class="grid">
            <div class="stack">
                <div class="card">
                    <h3>1. TIA Parameters (Excel Logic)</h3>
                    <div class="year-calc-info">
                        <strong>Project:</strong> <input type="text" id="tia_project" placeholder="Site Name" style="width:150px; padding:2px;">
                    </div>
                    <div class="params-grid">
                        <div><label>Current AADT:</label><input type="number" id="tia_aadt" value="25313"></div>
                        <div><label>Count Year:</label><input type="number" id="tia_year_data" value="2024"></div>
                        <div><label>Opening Year:</label><input type="number" id="tia_year_open" value="2026"></div>
                        <div><label>Growth (%):</label><input type="number" id="tia_growth" value="2.5" step="0.1"></div>
                    </div>
                    <div class="params-grid" style="margin-top:10px;">
                        <div><label>Lanes (Dir):</label><input type="number" id="tia_lanes" value="2"></div>
                        <div><label>HV (%):</label><input type="number" id="tia_hv" value="2.0"></div>
                        <div><label>CV (1-5):</label><input type="number" id="tia_cv" value="1" title="Coefficient of Variation"></div>
                        <div><label>Length Factor:</label><input type="number" id="tia_mult_factor" value="1.2" step="0.1" title="Multiplier adjustment (Excel uses ~1.2x time)"></div>
                    </div>
                    <div class="params-grid" style="margin-top:10px; border-top:1px solid #ddd; padding-top:10px;">
                        <div style="grid-column: span 2;">
                            <label>Capacity Logic:</label>
                            <select id="tia_cap_type">
                                <option value="user">User Defined Below</option>
                                <option value="2175">Urban Arterial (2175/ln)</option>
                                <option value="1800">Highway (1800/ln)</option>
                            </select>
                        </div>
                        <div style="grid-column: span 2;">
                            <label>Design Capacity (Total):</label>
                            <input type="number" id="tia_capacity" value="4350" title="Total Capacity for Direction">
                        </div>
                    </div>
                    <button onclick="calculateTIA()" style="margin-top:15px;">Run TIA Calculation</button>
                </div>

                <div class="card">
                    <h3>3. TIA Results (Peak Hour)</h3>
                    <table class="summary-table">
                        <thead>
                            <tr>
                                <th>Metric</th>
                                <th>Value</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td>Future AADT</td><td id="tia_res_aadt">-</td><td>-</td></tr>
                            <tr><td>Peak Hourly Vol (Design)</td><td id="tia_res_vol">-</td><td>80th Highest</td></tr>
                            <tr><td>Volume / Capacity (VCR)</td><td id="tia_res_vcr">-</td><td id="tia_res_los_badge">-</td></tr>
                        </tbody>
                    </table>

                    <h4 style="margin-top:15px; border-bottom: 2px solid #0056b3; color: #444;">Queue Length Estimation</h4>
                    <p style="font-size:0.85em; color:#666;">
                        Logic: Vol (5min) &times; Multiplier (Excel Table) &times; Lane/CV Factors
                    </p>
                    <table style="width:100%; text-align:center; font-size:0.9em; border-collapse:collapse;">
                        <tr style="background:#f1f1f1; font-weight:bold;">
                            <td style="padding:5px; border:1px solid #ddd;">Duration</td>
                            <td style="padding:5px; border:1px solid #ddd;">Multiplier</td>
                            <td style="padding:5px; border:1px solid #ddd;">Queue (m)</td>
                        </tr>
                        <tr><td>2 mins</td><td>2.4</td><td id="q_2m" style="font-weight:bold;">-</td></tr>
                        <tr><td>5 mins</td><td>6.0</td><td id="q_5m" style="font-weight:bold;">-</td></tr>
                        <tr><td>10 mins</td><td>12.0</td><td id="q_10m" style="font-weight:bold;">-</td></tr>
                        <tr><td>15 mins</td><td>18.0</td><td id="q_15m" style="font-weight:bold;">-</td></tr>
                        <tr><td>30 mins</td><td>36.0</td><td id="q_30m" style="font-weight:bold;">-</td></tr>
                    </table>
                </div>
            </div>

            <div class="card">
                <h3>2. Site Location (Gold Coast)</h3>
                <p style="font-size:0.85em; color:#555; margin: 0 0 8px 0;">Embedded Gold Coast GeoJSON loaded automatically.</p>
                <div id="interactiveMap" style="height: 500px; width: 100%; border: 2px solid #0056b3; border-radius:4px;"></div>
                <p style="font-size:0.85em; margin-top:5px; color: #666;">
                    üí° <strong>Tip:</strong> Click any marker on the map above to auto-fill TIA inputs OR manually enter values in the form
                </p>
                <div class="map-info" id="tiaQueueMapStatus">Select a site and run TIA to show the 5-min queue indicator on the map.</div>
            </div>
        </div>
    </div>

    <div id="Ipswich" class="tab-content">
        <div class="grid">
            <div class="stack">
                <div class="card">
                    <h3>1. Select Site</h3>
                    <div class="control-group">
                        <label>Search Site:</label>
                        <input type="text" id="ipswichSearch" placeholder="Search road name..." onkeyup="filterIpswichList()">
                        <select id="ipswichSiteSelect" size="3" onchange="selectIpswichSite(this.value)">
                            <option>Loading sites...</option>
                        </select>
                    </div>
                </div>

                <div class="card">
                    <h3>3. Analysis & Results</h3>
                    <div id="ipswichCalcArea" style="display:none; margin-top:10px;">
                        <h3 id="ipswichSelectedName" style="color:#d35400;"></h3>
                        
                        <div class="stat-grid" style="grid-template-columns: 1fr 1fr;">
                            <div class="control-group">
                                <label>Base AADT (<span id="ipswichBaseYear">2022</span>):</label>
                                <input type="number" id="ipswichInputAADT" onchange="updateIpswichAnalysis()">
                            </div>
                            <div class="control-group">
                                <label>Growth Rate (%):</label>
                                <input type="number" id="ipswichInputGrowth" step="0.1" value="2.5" onchange="updateIpswichAnalysis()">
                            </div>
                        </div>

                        <div class="stat-grid" style="grid-template-columns: 1fr 1fr;">
                            <div class="control-group">
                                <label>Target Year:</label>
                                <input type="number" id="ipswichTargetYear" value="2026" onchange="updateIpswichAnalysis()">
                            </div>
                            <div class="control-group">
                                <label>Heavy Vehicle %:</label>
                                <input type="number" id="ipswichInputHV" step="0.1" value="5.0" onchange="updateIpswichAnalysis()">
                            </div>
                        </div>

                        <div class="control-group">
                            <label>Analysis Road Adjustment:</label>
                            <div style="display:flex; gap:5px;">
                                <input type="text" id="ipswichAnalysisRoad" placeholder="Same as count loc" style="flex:2;">
                                <input type="number" id="ipswichAnalysisPct" value="100" placeholder="%" style="width:70px;" onchange="updateIpswichAnalysis()">
                                <span style="line-height:35px;">%</span>
                            </div>
                            <small>Enter % if analyzing a different road (e.g., 25%)</small>
                        </div>

                        <div class="control-group">
                            <label>Design Capacity (One Way vph):</label>
                            <input type="number" id="ipswichCapacity" value="500" onchange="updateIpswichAnalysis()">
                        </div>

                        <div class="result-box" style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; margin-top: 15px;">
                            <h4 style="margin-top:0;">Analysis Results</h4>
                            
                            <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                                <span>Projected AADT:</span>
                                <strong id="resAADT" style="font-size:1.2em;">-</strong>
                            </div>
                            <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                                <span>Peak Hr Vol (1-Way):</span>
                                <strong id="resPeakFlow">-</strong>
                            </div>
                            <div style="display:flex; justify-content:space-between; border-bottom:1px solid #555; padding-bottom:10px; margin-bottom:10px;">
                                <span>Volume/Capacity Ratio:</span>
                                <strong id="resVCR">-</strong>
                            </div>

                            <div style="text-align:center; margin-bottom:15px;">
                                <div style="font-size:0.9em; color:#bbb;">Level of Service</div>
                                <div id="resLOS" style="font-size:2em; font-weight:bold; color:white;">-</div>
                            </div>

                            <table style="width:100%; font-size:0.9em; text-align:right;">
                                <thead>
                                    <tr style="color:#aaa; border-bottom:1px solid #555;">
                                        <th style="text-align:left;">Queue Duration</th>
                                        <th>Vehicles</th>
                                        <th>Length (m)</th>
                                    </tr>
                                </thead>
                                <tbody id="resQueueTable">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>2. Site Location</h3>
                <div id="ipswichMap" style="height: 500px; width: 100%; border-radius: 4px; border: 2px solid #0056b3;"></div>
            </div>
        </div>
    </div>

<div id="Logan" class="tab-content">
    <div class="grid">
        <div class="stack">
            <div class="card">
                <h3>1. Select Site</h3>
                <div class="control-group">
                    <label>Search Site:</label>
                    <input type="text" id="loganSearch" placeholder="Search road name..." onkeyup="filterLoganList()">
                    <select id="loganSiteSelect" size="3" onchange="selectLoganSite(this.value)">
                        <option>Loading sites...</option>
                    </select>
                </div>
            </div>

            <div class="card">
                <h3>3. Analysis & Results</h3>
                <div id="loganCalcArea" style="display:none; margin-top:10px;">
                    <h3 id="loganSelectedName" style="color:#27ae60;"></h3>

                    <div class="stat-grid" style="grid-template-columns: 1fr 1fr;">
                        <div class="control-group">
                            <label>Base AADT (<span id="loganBaseYear">2022</span>):</label>
                            <input type="number" id="loganInputAADT" onchange="updateLoganAnalysis()">
                        </div>
                        <div class="control-group">
                            <label>Growth Rate (%):</label>
                            <input type="number" id="loganInputGrowth" step="0.1" value="2.5" onchange="updateLoganAnalysis()">
                        </div>
                    </div>

                    <div class="stat-grid" style="grid-template-columns: 1fr 1fr;">
                        <div class="control-group">
                            <label>Target Year:</label>
                            <input type="number" id="loganTargetYear" value="2026" onchange="updateLoganAnalysis()">
                        </div>
                        <div class="control-group">
                            <label>Heavy Vehicle %:</label>
                            <input type="number" id="loganInputHV" step="0.1" value="5.0" onchange="updateLoganAnalysis()">
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Analysis Road Adjustment:</label>
                        <div style="display:flex; gap:5px;">
                            <input type="text" id="loganAnalysisRoad" placeholder="Same as count loc" style="flex:2;">
                            <input type="number" id="loganAnalysisPct" value="100" placeholder="%" style="width:70px;" onchange="updateLoganAnalysis()">
                            <span style="line-height:35px;">%</span>
                        </div>
                        <small>Enter % if analyzing a different road (e.g., 25%)</small>
                    </div>

                    <div class="control-group">
                        <label>Design Capacity (One Way vph):</label>
                        <input type="number" id="loganCapacity" value="500" onchange="updateLoganAnalysis()">
                    </div>

                    <div class="result-box" style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; margin-top: 15px;">
                        <h4 style="margin-top:0;">Analysis Results</h4>

                        <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                            <span>Projected AADT:</span>
                            <strong id="loganResAADT" style="font-size:1.2em;">-</strong>
                        </div>
                        <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                            <span>Peak Hr Vol (1-Way):</span>
                            <strong id="loganResPeakFlow">-</strong>
                        </div>
                        <div style="display:flex; justify-content:space-between; border-bottom:1px solid #555; padding-bottom:10px; margin-bottom:10px;">
                            <span>Volume/Capacity Ratio:</span>
                            <strong id="loganResVCR">-</strong>
                        </div>

                        <div style="text-align:center; margin-bottom:15px;">
                            <div style="font-size:0.9em; color:#bbb;">Level of Service</div>
                            <div id="loganResLOS" style="font-size:2em; font-weight:bold; color:white;">-</div>
                        </div>

                        <table style="width:100%; font-size:0.9em; text-align:right;">
                            <thead>
                                <tr style="color:#aaa; border-bottom:1px solid #555;">
                                    <th style="text-align:left;">Queue Duration</th>
                                    <th>Vehicles</th>
                                    <th>Length (m)</th>
                                </tr>
                            </thead>
                            <tbody id="loganResQueueTable">
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <h3>2. Site Location</h3>
            <div id="loganMap" style="height: 500px; width: 100%; border-radius: 4px; border: 2px solid #0056b3;"></div>
        </div>
    </div>
</div>

<div id="tab-toowoomba" class="tab-content">
    <h1>Toowoomba Traffic Counts</h1>

    <div class="card">
        <h3>1. Data Source</h3>
        <div style="display: flex; gap: 10px; align-items: flex-end;">
            <div style="flex-grow: 1;">
                <label>GeoJSON URL:</label>
                <input type="text" id="geoJsonUrl" value="https://raw.githubusercontent.com/crsanju/Cromton_Traffic_Analysis/refs/heads/main/toowoomba.geojson">
            </div>
            <button style="width: auto;" onclick="loadGeoJson()">Load Data</button>
        </div>
        <div id="geoJsonStatus" style="margin-top: 10px;"></div>

        <div id="twSiteSelectDiv" class="hidden" style="margin-top: 15px;">
            <label>Select Site (Filtered from GeoJSON):</label>
            <select id="twSiteSelect" onchange="updateTwSiteInfo()"></select>
            <div id="twSiteInfo" style="margin-top: 10px; padding: 10px; background: #eef; border-radius: 4px;"></div>
        </div>
    </div>

    <div id="twParams" class="hidden card">
        <h3>2. TIA Parameters</h3>
        <div class="params-grid">
            <div><label>ADT (Count):</label><input type="number" id="twAdt" readonly></div>
            <div><label>Road Type:</label><select id="twRoadType"></select></div>
            <div><label>Count Year:</label><input type="number" id="twCountYear" value="2021"></div>
            <div><label>Target Year:</label><input type="number" id="twTargetYear" value="2025"></div>
        </div>
        <div class="params-grid">
            <div><label>Growth (%):</label><input type="number" id="twGrowth" value="2.5" step="0.1"></div>
            <div><label>CV (%):</label><input type="number" id="twCv" value="13" step="1"></div>
            <div><label>Lanes:</label><input type="number" id="twLanes" value="1"></div>
        </div>
        <button onclick="calcToowoomba()">Calculate Queue</button>
    </div>

    <div id="twResults" class="hidden">
        <div class="grid">
            <div class="card">
                <h3>3. Volume Estimation</h3>
                <table id="twVolTable">
                    <thead><tr><th>Metric</th><th>Peak (AM)</th><th>Off-Peak</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="card">
                <h3>4. Queue Estimation (Target Year)</h3>
                <table class="detail-table" id="twQueueTable">
                    <thead><tr><th>Duration</th><th>Peak Queue (m)</th><th>Off-Peak Queue (m)</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>
</div>


<!-- TMR Traffic Data loaded from GitHub -->

<script>
// Meta Data from your CSV
const dowFactors = {
    "Urban arterial 1 (Capital City)": {"Mon": 0.98}, "Urban arterial 1 (Other)": {"Mon": 1.01},
    "Urban arterial 2 (Capital City)": {"Mon": 0.99}, "Urban arterial 2 (Others)": {"Mon": 1},
    "Urban CBD (Capital City)": {"Mon": 1.02}, "Urban industrial (Others)": {"Mon": 0.85},
    "Rural urban fringe": {"Mon": 1.14}, "Rural strategic 1": {"Mon": 1.05},
    "Rural strategic 2": {"Mon": 1.11}, "Rural recreation summer": {"Mon": 1.07}, "Rural recreation winter": {"Mon": 1.15}
};

const partDayFactors = {
    "Urban arterial (Capital City)": {"7-9am": 5.63}, "Urban arterial (Others)": {"7-9am": 7.31},
    "Urban CBD (Capital City)": {"7-9am": 7.86}, "Urban industrial (Others)": {"7-9am": 5.57},
    "Rural urban fringe": {"7-9am": 8.61}, "Rural strategic 1": {"7-9am": 8.4},
    "Rural strategic 2": {"7-9am": 10.2}, "Rural recreation summer": {"7-9am": 16.9}, "Rural recreation winter": {"7-9am": 13.8}
};

let twGeoData = null;

// GitHub Configuration
const GITHUB_CONFIG = {
    username: 'crsanju',
    repo: 'Cromton_Traffic_Analysis',
    branch: '828cc3faa7d44bdc483d06def9af6c9f1c409ed5',
    tmrDataFile: 'tmr.geojson',
    goldCoastDataFile: 'goldcoast.geojson'
};

const GITHUB_TMR_URL = `https://raw.githubusercontent.com/${GITHUB_CONFIG.username}/${GITHUB_CONFIG.repo}/main/${GITHUB_CONFIG.tmrDataFile}`;
const GITHUB_GOLDCOAST_URL = 'https://raw.githubusercontent.com/crsanju/Cromton_Traffic_Analysis/main/goldcoast.geojson';

// Fetch data from GitHub
async function fetchGitHubData(url) {
    try {
        console.log('Fetching data from:', url);
        const response = await fetch(url);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('Data fetched successfully');
        return data;
    } catch (err) {
        console.error('Failed to fetch data from GitHub:', err);
        throw new Error('Failed to load traffic data from GitHub: ' + err.message);
    }
}

// Data getters (updated for GitHub)
window.getGitHubTMRData = async function() {
    return await fetchGitHubData(GITHUB_TMR_URL);
};

window.getGitHubGeoJSON = async function() {
    return await fetchGitHubData(GITHUB_GOLDCOAST_URL);
};

// Hide loading overlay
function hideLoading() {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) {
        overlay.style.display = 'none';
    }
}

// Show error message
function showError(message) {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) {
        overlay.innerHTML = `
            <div class="loading-content">
                <h2 style="color: #c00000;">‚ö†Ô∏è Error Loading Data</h2>
                <p style="margin: 20px 0;">${message}</p>
                <p style="font-size: 14px; color: #666;">
                    Please ensure:<br>
                    ‚Ä¢ You have internet connection<br>
                    ‚Ä¢ The GitHub repository is public<br>
                    ‚Ä¢ The file exists at the specified URL
                </p>
                <button onclick="location.reload()" style="margin-top: 20px; padding: 10px 20px; background: #0056b3; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Retry
                </button>
            </div>
        `;
    }
}
</script>

<script>
    let sitesData = {};
    let markerClusterGroup = null;

    // Debounce utility for performance
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // Initialize Dropdown
    (function initTw() {
        const rtSelect = document.getElementById('twRoadType');
        if (!rtSelect) return;
        for (const rt in dowFactors) {
            const opt = document.createElement('option');
            opt.value = rt;
            opt.textContent = rt;
            rtSelect.appendChild(opt);
        }
    })();

    // Load Data
    async function loadGeoJson() {
        const url = document.getElementById('geoJsonUrl').value;
        const status = document.getElementById('geoJsonStatus');
        status.innerHTML = '<span class="loader"></span> Loading...';
        try {
            const resp = await fetch(url);
            if (!resp.ok) throw new Error("Network response was not ok");
            const data = await resp.json();
            twGeoData = data;
            status.innerHTML = `<span style="color:green">Success! Loaded ${data.features.length} sites.</span>`;
            
            const sel = document.getElementById('twSiteSelect');
            sel.innerHTML = '<option value="">Select a site...</option>';
            twGeoData.features.forEach((f, i) => {
                const props = f.properties;
                const name = props.Road_Name || props.ROAD_NAME || props.Street || `Site ${i}`;
                const loc = props.Location || props.Count_Location || '';
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = `${name} - ${loc}`;
                sel.appendChild(opt);
            });
            document.getElementById('twSiteSelectDiv').classList.remove('hidden');
        } catch (e) {
            status.innerHTML = `<span style="color:red">Error: ${e.message}</span>`;
        }
    }

    // Update UI on Site Select
    function updateTwSiteInfo() {
        const idx = document.getElementById('twSiteSelect').value;
        if (idx === "") { document.getElementById('twParams').classList.add('hidden'); return; }
        
        const props = twGeoData.features[idx].properties;
        let html = '<strong>Properties:</strong><br>';
        for(const k in props) html += `${k}: ${props[k]}<br>`;
        document.getElementById('twSiteInfo').innerHTML = html;
        
        document.getElementById('twAdt').value = props.ADT || props.adt || 0;
        
        // Attempt to auto-select Road Type and Year
        const rt = props.Road_Type || props.ROAD_TYPE || '';
        const rtSelect = document.getElementById('twRoadType');
        for(let i=0; i<rtSelect.options.length; i++) {
            if (rtSelect.options[i].value === rt) { rtSelect.selectedIndex = i; break; }
        }
        const date = props.Count_Date || props.COUNT_DATE;
        if (date) {
            const y = new Date(date).getFullYear();
            if(!isNaN(y)) document.getElementById('twCountYear').value = y;
        }
        document.getElementById('twParams').classList.remove('hidden');
    }

    // Calculate Function
    function calcToowoomba() {
        const adt = parseFloat(document.getElementById('twAdt').value);
        const cy = parseFloat(document.getElementById('twCountYear').value);
        const ty = parseFloat(document.getElementById('twTargetYear').value);
        const gr = parseFloat(document.getElementById('twGrowth').value);
        const cvPct = parseFloat(document.getElementById('twCv').value);
        const lanes = parseFloat(document.getElementById('twLanes').value);
        
        const years = Math.max(0, ty - cy);
        const aadtFut = adt * Math.pow(1 + gr/100, years);

        const kFactor = 0.13;
        const dFactor = 0.50;
        const peakHr = aadtFut * kFactor * dFactor;
        const offPeakHr = Math.max(0, Math.floor((aadtFut - (peakHr * 2)) / 22));

        document.querySelector('#twVolTable tbody').innerHTML = `
            <tr><td>Hourly Vol (Total)</td><td>${Math.round(peakHr)}</td><td>${offPeakHr}</td></tr>
            <tr><td>Hourly Vol (Per Lane)</td><td>${Math.round(peakHr/lanes)}</td><td>${Math.round(offPeakHr/lanes)}</td></tr>
        `;

        const hvPercent = Math.max(0, cvPct) / 100;
        const calcQ = (volHr) => {
            const vehPerMin = volHr / 60;
            const durations = [2, 5, 10, 15];
            return durations.map(mins => {
                const totalVeh = Math.ceil((vehPerMin * mins) / lanes);
                const nHv = Math.ceil(totalVeh * hvPercent);
                const nCar = Math.max(0, totalVeh - nHv);
                return (nCar * 7) + (nHv * 18);
            });
        };

        const pQ = calcQ(peakHr);
        const oQ = calcQ(offPeakHr);

        document.querySelector('#twQueueTable tbody').innerHTML = `
            <tr><td>2 min</td><td>${Math.round(pQ[0])}</td><td>${Math.round(oQ[0])}</td></tr>
            <tr><td>5 min</td><td>${Math.round(pQ[1])}</td><td>${Math.round(oQ[1])}</td></tr>
            <tr><td>10 min</td><td>${Math.round(pQ[2])}</td><td>${Math.round(oQ[2])}</td></tr>
            <tr><td>15 min</td><td>${Math.round(pQ[3])}</td><td>${Math.round(oQ[3])}</td></tr>
        `;
        document.getElementById('twResults').classList.remove('hidden');
    }

    async function getEmbeddedTmrRawData() {
        return await getGitHubTMRData();
    }

    function normalizeTrafficData(rawData) {
        if (rawData && Array.isArray(rawData.fields) && Array.isArray(rawData.records)) {
            return rawData;
        }

        if (rawData && rawData.type === 'FeatureCollection' && Array.isArray(rawData.features)) {
            const fieldIds = [
                'SITE_ID', 'DESCRIPTION', 'SITE_DISTANCE', 'LONGITUDE', 'LATITUDE',
                'RSECT_ID', 'ROAD_NAME', 'TDIST_START', 'TDIST_END', 'GAZETTAL_DIRECTION',
                'HOURS', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN',
                'WEEKDAY_AVERAGE', 'WEEKEND_AVERAGE'
            ];

            return {
                fields: [{ id: '_id', type: 'int' }, ...fieldIds.map(id => ({ id }))],
                records: rawData.features.map((feature, index) => {
                    const properties = feature.properties || {};
                    const coordinates = feature.geometry && Array.isArray(feature.geometry.coordinates)
                        ? feature.geometry.coordinates
                        : [null, null];

                    return [
                        index + 1,
                        ...fieldIds.map(fieldId => {
                            if (fieldId === 'LONGITUDE') {
                                return properties[fieldId] ?? coordinates[0];
                            }
                            if (fieldId === 'LATITUDE') {
                                return properties[fieldId] ?? coordinates[1];
                            }
                            return properties[fieldId];
                        })
                    ];
                })
            };
        }

        const avgVolumes = rawData && rawData['2024 Avg Volumes'];
        if (Array.isArray(avgVolumes)) {
            const fieldIds = [
                'SITE_ID', 'DESCRIPTION', 'SITE_DISTANCE', 'LONGITUDE', 'LATITUDE',
                'RSECT_ID', 'ROAD_NAME', 'TDIST_START', 'TDIST_END', 'GAZETTAL_DIRECTION',
                'HOURS', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN',
                'WEEKDAY_AVERAGE', 'WEEKEND_AVERAGE'
            ];

            return {
                fields: [{ id: '_id', type: 'int' }, ...fieldIds.map(id => ({ id }))],
                records: avgVolumes.map((row, index) => [
                    index + 1,
                    ...fieldIds.map(fieldId => row[fieldId])
                ])
            };
        }

        throw new Error('Unsupported TMR JSON format.');
    }

    async function loadTrafficData() {
        try {
            console.log('Starting to load traffic data from GitHub...');
            const rawData = await getEmbeddedTmrRawData();
            console.log('Raw data loaded, normalizing...');
            const normalizedJsonData = normalizeTrafficData(rawData);
            console.log('Data normalized, parsing...');
            sitesData = parseTrafficData(normalizedJsonData);
            console.log('Data parsed successfully, initializing site list...');
            await initializeSiteList();
            console.log('Traffic data loaded successfully!');
            hideLoading();
        } catch (error) {
            console.error('Error loading traffic data:', error);
            showError(error.message);
        }
    }

    function parseTrafficData(jsonData) {
        const sites = {};
        const fieldMap = {};
        
        // Create field index map
        jsonData.fields.forEach((field, index) => {
            fieldMap[field.id] = index;
        });
        
        // Process each record
        jsonData.records.forEach(record => {
            const siteId = String(record[fieldMap['SITE_ID']]);
            const description = record[fieldMap['DESCRIPTION']].replace(/"/g, '');
            const roadName = record[fieldMap['ROAD_NAME']].replace(/"/g, '');
            const direction = record[fieldMap['GAZETTAL_DIRECTION']];
            const hours = record[fieldMap['HOURS']];
            const weekdayAvg = record[fieldMap['WEEKDAY_AVERAGE']];
            const longitude = record[fieldMap['LONGITUDE']];
            const latitude = record[fieldMap['LATITUDE']];
            
            // Initialize site if not exists
            if (!sites[siteId]) {
                sites[siteId] = {
                    description: description,
                    road_name: roadName,
                    longitude: longitude,
                    latitude: latitude,
                    directions: {
                        'GAZETTAL': new Array(24).fill(0),
                        'AGAINST GAZETTAL': new Array(24).fill(0)
                    }
                };
            }
            
            // Parse hour range (e.g., "0 to 1" -> hour 0)
            const hourMatch = hours.match(/^(\d+)\s+to\s+(\d+)$/);
            if (hourMatch && sites[siteId].directions[direction]) {
                const hourIndex = parseInt(hourMatch[1]);
                if (hourIndex >= 0 && hourIndex < 24) {
                    sites[siteId].directions[direction][hourIndex] = weekdayAvg;
                }
            }
        });
        
        return sites;
    }
    
    const siteInput = document.getElementById('siteInput');
    const sitesList = document.getElementById('sites');
    let hourlyMap;
    let hourlySiteLayer;
    let hourlySiteMarkers = {};
    let selectedHourlySiteId = null;

    function addTileLayerWithFallback(targetMap, primaryUrl, primaryOptions, fallbackUrl, fallbackOptions) {
        const primaryLayer = L.tileLayer(primaryUrl, primaryOptions);
        const fallbackLayer = L.tileLayer(fallbackUrl, fallbackOptions);
        let errorCount = 0;
        let fallbackAdded = false;

        primaryLayer.on('tileerror', () => {
            errorCount += 1;
            if (!fallbackAdded && errorCount >= 5) {
                fallbackAdded = true;
                targetMap.addLayer(fallbackLayer);
                targetMap.removeLayer(primaryLayer);
            }
        });

        primaryLayer.addTo(targetMap);
    }

    function initHourlyMap() {
        if (hourlyMap) return;

        hourlyMap = L.map('map').setView([-28.00, 153.40], 10);
        addTileLayerWithFallback(
            hourlyMap,
            'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            { attribution: '&copy; OpenStreetMap contributors' },
            'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
            { attribution: '&copy; OpenStreetMap contributors &copy; CARTO' }
        );
    }

    function resetSelectedHourlyMarker() {
        if (selectedHourlySiteId && hourlySiteMarkers[selectedHourlySiteId]) {
            hourlySiteMarkers[selectedHourlySiteId].setStyle({
                radius: 5,
                fillColor: '#ff7800',
                color: '#000',
                weight: 1,
                opacity: 1,
                fillOpacity: 0.8
            });
        }
    }

    function highlightHourlyMarker(siteId) {
        resetSelectedHourlyMarker();
        selectedHourlySiteId = siteId;

        if (hourlySiteMarkers[siteId]) {
            hourlySiteMarkers[siteId].setStyle({
                radius: 8,
                fillColor: '#0056b3',
                color: '#003366',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.95
            });
            hourlySiteMarkers[siteId].openPopup();
        }
    }

    function populateHourlyMapSites(searchTerm = '') {
        if (!hourlyMap) return;

        const normalizedSearch = String(searchTerm || '').trim().toLowerCase();
        const mapCountEl = document.getElementById('tmrMapCount');

        // Remove existing layers
        if (hourlySiteLayer) {
            hourlyMap.removeLayer(hourlySiteLayer);
        }
        if (markerClusterGroup) {
            hourlyMap.removeLayer(markerClusterGroup);
        }

        hourlySiteMarkers = {};
        const bounds = [];
        
        // Create marker cluster group for better performance
        markerClusterGroup = L.markerClusterGroup({
            maxClusterRadius: 50,
            spiderfyOnMaxZoom: true,
            showCoverageOnHover: false,
            zoomToBoundsOnClick: true
        });

        let markerCount = 0;
        const totalSites = Object.keys(sitesData).length;
        
        // Use requestAnimationFrame for smoother rendering
        const entries = Object.entries(sitesData);
        const batchSize = 100; // Process markers in batches
        let currentIndex = 0;

        function processBatch() {
            const endIndex = Math.min(currentIndex + batchSize, entries.length);
            
            for (let i = currentIndex; i < endIndex; i++) {
                const [siteId, data] = entries[i];
                
                if (!data || !data.latitude || !data.longitude) continue;

                const searchable = `${siteId} ${data.road_name || ''} ${data.description || ''}`.toLowerCase();
                if (normalizedSearch && !searchable.includes(normalizedSearch)) continue;

                const lat = Number(data.latitude);
                const lon = Number(data.longitude);
                if (Number.isNaN(lat) || Number.isNaN(lon)) continue;

                const marker = L.circleMarker([lat, lon], {
                    radius: 5,
                    fillColor: '#ff7800',
                    color: '#000',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                });

                marker.bindPopup(`
                    <strong>${siteId}</strong><br>
                    ${data.road_name}<br>
                    ${data.description}<br>
                    ${lat.toFixed(6)}, ${lon.toFixed(6)}<br>
                    <button onclick="selectSiteFromMap('${siteId}')" style="background-color: #0056b3; color: white; padding: 5px 10px; border: none; border-radius: 3px; cursor: pointer; margin-top: 5px;">Select for Analysis</button>
                `);

                marker.bindTooltip(`${siteId}`, {
                    permanent: true,
                    direction: 'top',
                    offset: [0, -8],
                    className: 'site-id-label'
                });

                marker.on('click', () => {
                    selectSiteFromMap(siteId);
                });

                hourlySiteMarkers[siteId] = marker;
                markerClusterGroup.addLayer(marker);
                bounds.push([lat, lon]);
                markerCount++;
            }
            
            currentIndex = endIndex;
            
            if (currentIndex < entries.length) {
                // Process next batch
                requestAnimationFrame(processBatch);
            } else {
                // Finished processing all markers
                hourlyMap.addLayer(markerClusterGroup);
                
                if (mapCountEl) {
                    mapCountEl.textContent = `Showing ${markerCount} of ${totalSites} sites`;
                }

                if (bounds.length > 0) {
                    hourlyMap.fitBounds(bounds, { padding: [20, 20] });
                }

                if (selectedHourlySiteId && hourlySiteMarkers[selectedHourlySiteId]) {
                    highlightHourlyMarker(selectedHourlySiteId);
                } else if (selectedHourlySiteId && !hourlySiteMarkers[selectedHourlySiteId]) {
                    selectedHourlySiteId = null;
                }
            }
        }
        
        // Start processing
        processBatch();
    }
    

    window.selectSiteFromMap = function(siteId) {
        siteInput.value = siteId;
        siteInput.dispatchEvent(new Event('change'));
        
        // Scroll to and focus on the search field for visual feedback
        siteInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
        siteInput.focus();
        
        // Add visual highlight effect
        siteInput.style.transition = 'background-color 0.3s';
        siteInput.style.backgroundColor = '#ffffcc';
        setTimeout(() => {
            siteInput.style.backgroundColor = '';
        }, 1000);
    };
    
    // Initialize Datalist (optimized with batching)
    function initializeSiteList() {
        return new Promise((resolve) => {
            const entries = Object.entries(sitesData);
            const batchSize = 200;
            let currentIndex = 0;
            
            sitesList.innerHTML = ''; // Clear existing options
            
            function processBatch() {
                const fragment = document.createDocumentFragment();
                const endIndex = Math.min(currentIndex + batchSize, entries.length);
                
                for (let i = currentIndex; i < endIndex; i++) {
                    const [id, data] = entries[i];
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = `${id} - ${data.description}`;
                    fragment.appendChild(option);
                }
                
                sitesList.appendChild(fragment);
                currentIndex = endIndex;
                
                if (currentIndex < entries.length) {
                    // Process next batch
                    requestAnimationFrame(processBatch);
                } else {
                    // Finished - initialize map and resolve
                    initHourlyMap();
                    populateHourlyMapSites();
                    resolve();
                }
            }
            
            processBatch();
        });
    }
    
    // Load data on page load
    loadTrafficData();

    // Debounced search for better performance
    const debouncedSearch = debounce((value) => {
        populateHourlyMapSites(value);
    }, 300);

    siteInput.addEventListener('input', (e) => {
        debouncedSearch(e.target.value);
    });

    siteInput.addEventListener('change', () => {
        const siteId = siteInput.value;
        const data = sitesData[siteId];
        if (data) {
            populateHourlyMapSites();
            document.getElementById('siteInfo').classList.remove('hidden');
            document.getElementById('roadName').textContent = data.road_name;
            document.getElementById('siteDesc').textContent = data.description;
            
            // Show and update Google Maps link
            if (data.latitude && data.longitude) {
                const lat = data.latitude;
                const lon = data.longitude;
                document.getElementById('mapCoords').textContent = `${lat.toFixed(6)}, ${lon.toFixed(6)}`;
                document.getElementById('mapLink').href = `https://www.google.com/maps/search/?api=1&query=${lat},${lon}`;

                if (hourlyMap) {
                    hourlyMap.setView([lat, lon], 14);
                }
                highlightHourlyMarker(siteId);
            }
            
            // Show raw data table
            displayRawData(data);
            document.getElementById('rawDataSection').classList.remove('hidden');
        } else {
               populateHourlyMapSites(siteInput.value);
             document.getElementById('siteInfo').classList.add('hidden');
             document.getElementById('rawDataSection').classList.add('hidden');
               document.getElementById('mapCoords').textContent = '-';
               document.getElementById('mapLink').href = '#';
               resetSelectedHourlyMarker();
               selectedHourlySiteId = null;
        }
    });

    function displayRawData(site) {
        const tbody = document.getElementById('rawDataTable').querySelector('tbody');
        tbody.innerHTML = '';
        
        const gazettalData = site.directions['GAZETTAL'] || new Array(24).fill(0);
        const againstData = site.directions['AGAINST GAZETTAL'] || new Array(24).fill(0);
        
        for (let hour = 0; hour < 24; hour++) {
            const row = tbody.insertRow();
            row.insertCell(0).textContent = `${hour}:00 - ${hour + 1}:00`;
            row.insertCell(1).textContent = Math.round(gazettalData[hour]);
            row.insertCell(2).textContent = Math.round(againstData[hour]);
        }
    }

    function updateYears() {
        const dYear = parseFloat(document.getElementById('dataYear').value);
        const oYear = parseFloat(document.getElementById('openingYear').value);
        const diff = oYear - dYear;
        document.getElementById('calcYears').textContent = diff > 0 ? diff : 0;
    }
    
    function updateAutoCapacity() {
        const roadType = document.getElementById('roadType').value;
        const capacityInput = document.getElementById('capacity');
        
        // Capacity values based on Austroads/TMR standards
        const capacityMap = {
            'freeway': 2100,      // Maximum Sustainable Flow Rate for high-speed
            'highway': 1800,      // Standard multi-lane highway
            'arterial_high': 1400, // Coordinated signals, no parking
            'arterial_urban': 1000, // Typical urban environment
            'signals': 1900       // Saturation flow rate base (ideal)
        };

        if (roadType && capacityMap[roadType]) {
            capacityInput.value = capacityMap[roadType];
            
            // Visual feedback that the value was updated
            capacityInput.style.backgroundColor = "#e7f3ff";
            setTimeout(() => { capacityInput.style.backgroundColor = ""; }, 500);
        }
    }
    
    // Initial call
    updateYears();
    updateAadtCap();

    let chartInstance = null;

    function getLOS(vcr) {
        if (vcr <= 0.60) return 'A';
        if (vcr <= 0.70) return 'B';
        if (vcr <= 0.80) return 'C';
        if (vcr <= 0.90) return 'D';
        if (vcr <= 1.00) return 'E';
        return 'F';
    }

    function getStatusClass(vcr) {
        if (vcr <= 0.80) return 'status-green'; 
        if (vcr <= 0.90) return 'status-yellow'; 
        return 'status-red'; 
    }

    function calculate() {
        // Check for manual AADT input first
        const manualAadt = parseFloat(document.getElementById('manualAadt').value);
        const kFactor = parseFloat(document.getElementById('kFactor').value) / 100;
        const dSplit = parseFloat(document.getElementById('dSplit').value) / 100;

        if (!isNaN(manualAadt) && manualAadt > 0) {
            // Calculate Peak Hour Volume from AADT
            // Formula: Peak Hour = AADT * K * D
            const estimatedPeakHourVol = manualAadt * kFactor * dSplit;
            processAadtQueue(estimatedPeakHourVol);
            return;
        }

        // Standard calculation using site data
        const siteId = siteInput.value;
        if (!sitesData[siteId]) { alert("Select a site first"); return; }
        
        const site = sitesData[siteId];
        const growth = parseFloat(document.getElementById('growthRate').value);
        const dYear = parseFloat(document.getElementById('dataYear').value);
        const oYear = parseFloat(document.getElementById('openingYear').value);
        const years = Math.max(0, oYear - dYear);
        
        const hv = parseFloat(document.getElementById('hvPercent').value);
        const baseLanes = parseFloat(document.getElementById('lanes').value);
        const capPerLane = parseFloat(document.getElementById('capacity').value);
        
        const growthFactor = Math.pow(1 + growth/100, years);
        // Note: For VCR calc, Excel seems to use RAW Volume / Capacity (Capacity adjusted for HV?)
        // OR Volume adjusted for HV. My analysis showed Volume Adjusted by PCE ~ 1.14 matched best.
        // But to be generic, we usually use PCE = 1 + HV/100 * (PCE_HV-1).
        // I will use standard PCE = 1 + HV/100 (HV=2.0). 
        // Note: Queue Calc uses raw volume breakdown. VCR uses PCE volume.
        
        const pceFactor = 1 + (hv/100); 

        document.getElementById('displayYear').textContent = oYear;

        const labels = Array.from({length: 24}, (_, i) => `${i}:00`);
        const datasetGaz = site.directions['GAZETTAL'] || new Array(24).fill(0);
        const datasetAg = site.directions['AGAINST GAZETTAL'] || new Array(24).fill(0);
        const datasetGazFut = datasetGaz.map(v => v * growthFactor);
        const datasetAgFut = datasetAg.map(v => v * growthFactor);

        updateChart(labels, datasetGaz, datasetGazFut, datasetAg, datasetAgFut);

        // --- Summary Table ---
        const periods = ['AM', 'OP', 'PM', 'EV'];
        const periodHours = {
            'AM': [7,8], 'OP': [9,10,11,12,13,14,15], 'PM': [16,17], 
            'EV': [18,19,20,21,22,23,0,1,2,3,4,5,6]
        };

        function calcVCRs(volArray, numLanes) {
            const cap = numLanes * capPerLane;
            return periods.map(p => {
                const hours = periodHours[p];
                let maxVol = 0;
                hours.forEach(h => { if(volArray[h] > maxVol) maxVol = volArray[h]; });
                const designVol = maxVol * pceFactor;
                const vcr = designVol / cap;
                return { vcr: vcr, los: getLOS(vcr) }; 
            });
        }

        const resGaz = calcVCRs(datasetGazFut, baseLanes);
        const resAg = calcVCRs(datasetAgFut, baseLanes);
        const resGazClose = calcVCRs(datasetGazFut, Math.max(1, baseLanes - 1));
        const resAgClose = calcVCRs(datasetAgFut, Math.max(1, baseLanes - 1));
        
        let resGazRev = null;
        let resAgRev = null;
        if (baseLanes > 1) {
            resGazRev = calcVCRs(datasetGazFut, baseLanes + 1);
            resAgRev = calcVCRs(datasetAgFut, baseLanes + 1);
        }

        const tbody = document.querySelector('#summaryTable tbody');
        tbody.innerHTML = '';

        function addRow(label, results) {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td class="row-header">${label}</td>` + 
                results.map(r => `<td class="${getStatusClass(r.vcr)}">${r.vcr.toFixed(2)} (${r.los})</td>`).join('');
            tbody.appendChild(tr);
        }

        addRow('Against Gazettal (Base)', resAg);
        addRow('Gazettal (Base)', resGaz);
        addRow('Single Lane Closure - Against Gazettal', resAgClose);
        addRow('Single Lane Closure - Gazettal', resGazClose);
        
        if (resGazRev) {
            addRow('Reversible Flow - Ag (+1 Ln)', resAgRev);
            addRow('Reversible Flow - Gaz (+1 Ln)', resGazRev);
        } else {
             const tr = document.createElement('tr');
             tr.innerHTML = `<td class="row-header">Reversible Flow</td><td colspan="4">N/A (Lanes < 2)</td>`;
             tbody.appendChild(tr);
        }

        // --- Detailed Queue Views ---
        processDetail('GAZETTAL', datasetGazFut, hv, baseLanes, 'gazettal-content', 'gazettal-queue', 'blockageTableGaz', 'lvGaz', 'hvGaz', 'totGaz');
        processDetail('AGAINST GAZETTAL', datasetAgFut, hv, baseLanes, 'against-content', 'against-queue', 'blockageTableAg', 'lvAg', 'hvAg', 'totAg');

        document.getElementById('results').classList.remove('hidden');
    }

    function processDetail(dirName, futureVols, hvPercent, lanes, contentId, queueDivId, tableId, lvId, hvId, totId) {
        const sum = futureVols.reduce((a,b)=>a+b, 0);
        if (sum === 0) {
            document.getElementById(contentId).innerHTML = 'No data';
            document.getElementById(queueDivId).classList.add('hidden');
            return;
        }
        document.getElementById(contentId).innerHTML = '';
        document.getElementById(queueDivId).classList.remove('hidden');

        // Find absolute peak volume
        let peakVol = 0;
        futureVols.forEach(v => { if(v > peakVol) peakVol = v; });

        // Calculate 5-minute Volume PER LANE
        const volPerLane = peakVol / lanes;
        const vol5min = volPerLane / 12;
        
        const volHV = vol5min * (hvPercent / 100);
        const volLV = vol5min - volHV;

        document.getElementById(totId).textContent = vol5min.toFixed(1);
        document.getElementById(lvId).textContent = volLV.toFixed(1);
        document.getElementById(hvId).textContent = volHV.toFixed(1);

        const steps = [
            { min: 2, lv: 2.4, hv: 8 },
            { min: 5, lv: 6, hv: 20 },
            { min: 10, lv: 12, hv: 40 },
            { min: 15, lv: 18, hv: 60 },
            { min: 30, lv: 36, hv: 120 }
        ];

        let html = '';
        steps.forEach(step => {
            const queue = (volLV * step.lv) + (volHV * step.hv);
            html += `
                <tr>
                    <td>${step.min} min</td>
                    <td>${step.lv}</td>
                    <td>${step.hv}</td>
                    <td><strong>${Math.round(queue)}</strong></td>
                </tr>
            `;
        });
        document.getElementById(tableId).innerHTML = html;
    }

    function processAadtQueue(peakVol) {
        // This helper maps manual peak volume into the existing queue logic
        const growth = parseFloat(document.getElementById('growthRate').value);
        const dYear = parseFloat(document.getElementById('dataYear').value);
        const oYear = parseFloat(document.getElementById('openingYear').value);
        const years = Math.max(0, oYear - dYear);
        const growthFactor = Math.pow(1 + growth/100, years);
        
        const hvPercent = parseFloat(document.getElementById('hvPercent').value);
        const lanes = parseInt(document.getElementById('lanes').value);
        
        const futPeakVol = peakVol * growthFactor;
        const volPerLane = futPeakVol / lanes;
        const vol5min = volPerLane / 12; // 5-min slice per lane
        
        const volHV = vol5min * (hvPercent / 100);
        const volLV = vol5min - volHV;

        // Update UI for Gazettal direction (using AADT-derived peak)
        document.getElementById('lvGaz').textContent = volLV.toFixed(1);
        document.getElementById('hvGaz').textContent = volHV.toFixed(1);
        document.getElementById('totGaz').textContent = vol5min.toFixed(1);
        
        // Generate queue table
        updateBlockageTable('blockageTableGaz', volLV, volHV);
        
        // Clear Against Gazettal (not applicable for AADT input)
        document.getElementById('against-content').innerHTML = '<em>AADT mode: Gazettal direction only</em>';
        document.getElementById('against-queue').classList.add('hidden');
        
        // Show results
        document.getElementById('gazettal-queue').classList.remove('hidden');
        document.getElementById('results').classList.remove('hidden');
        document.getElementById('displayYear').textContent = oYear;
        
        // Clear summary table for AADT mode
        const tbody = document.querySelector('#summaryTable tbody');
        tbody.innerHTML = '<tr><td colspan="5" style="text-align:center;"><em>AADT Mode: VCR summary not available. See queue estimation below.</em></td></tr>';
    }

    function updateBlockageTable(tableId, volLV, volHV) {
        const steps = [
            { min: 2, lv: 2.4, hv: 8 },
            { min: 5, lv: 6, hv: 20 },
            { min: 10, lv: 12, hv: 40 },
            { min: 15, lv: 18, hv: 60 },
            { min: 30, lv: 36, hv: 120 }
        ];

        let html = '';
        steps.forEach(step => {
            const queue = (volLV * step.lv) + (volHV * step.hv);
            html += `
                <tr>
                    <td>${step.min} min</td>
                    <td>${step.lv}</td>
                    <td>${step.hv}</td>
                    <td><strong>${Math.round(queue)}</strong></td>
                </tr>
            `;
        });
        document.getElementById(tableId).innerHTML = html;
    }

    function updateChart(labels, gCur, gFut, aCur, aFut) {
        if (chartInstance) chartInstance.destroy();
        const ctx = document.getElementById('trafficChart').getContext('2d');
        chartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    { label: 'Gazettal (Cur)', data: gCur, borderColor: '#0056b3', tension: 0.3, pointRadius: 0 },
                    { label: 'Gazettal (Fut)', data: gFut, borderColor: '#0056b3', borderDash: [5,5], tension: 0.3, pointRadius: 0 },
                    { label: 'Against (Cur)', data: aCur, borderColor: '#dc3545', tension: 0.3, pointRadius: 0 },
                    { label: 'Against (Fut)', data: aFut, borderColor: '#dc3545', borderDash: [5,5], tension: 0.3, pointRadius: 0 }
                ]
            },
            options: {
                responsive: true,
                interaction: { mode: 'index', intersect: false },
                scales: { y: { beginAtZero: true, title: {display:true, text: 'Volume (vph)'} } }
            }
        });
    }

    // --- TAB FUNCTIONALITY ---
    function openTab(evt, tabName) {
        var i, tabcontent, tablinks;
        tabcontent = document.getElementsByClassName("tab-content");
        for (i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
            tabcontent[i].classList.remove("active");
        }
        tablinks = document.getElementsByClassName("tab-button");
        for (i = 0; i < tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
        }
        document.getElementById(tabName).style.display = "block";
        document.getElementById(tabName).classList.add("active");
        evt.currentTarget.className += " active";
    }

    // --- AADT CALCULATOR LOGIC ---
    function updateAadtCap() {
        document.getElementById('aadt_cap').value = document.getElementById('aadt_road_type').value;
    }

    function calculateAADTLogic() {
        // 1. Get Inputs
        const aadt = parseFloat(document.getElementById('aadt_val').value) || 0;
        const yearData = parseInt(document.getElementById('aadt_year_data').value);
        const yearProj = parseInt(document.getElementById('aadt_year_proj').value);
        const growth = parseFloat(document.getElementById('aadt_growth').value) / 100;
        const hv = parseFloat(document.getElementById('aadt_hv').value) / 100;
        const lanes = parseInt(document.getElementById('aadt_lanes').value);
        const capacity = parseInt(document.getElementById('aadt_cap').value);
        const k = parseFloat(document.getElementById('aadt_k').value) / 100;
        const d = parseFloat(document.getElementById('aadt_d').value) / 100;

        // 2. Forecast AADT
        const yearsDiff = Math.max(0, yearProj - yearData);
        // Compound growth formula
        const futureAadt = aadt * Math.pow((1 + growth), yearsDiff);

        // 3. Peak Hour Calculations
        const dhv = futureAadt * k * d; // Directional Design Hourly Volume
        const volPerLane = dhv / lanes;
        const vcRatio = volPerLane / capacity;

        // 4. Determine LOS (Approximation based on v/c)
        let los = "A", losClass = "los-a";
        if (vcRatio > 1.00) { los = "F"; losClass = "los-f"; }
        else if (vcRatio > 0.90) { los = "E"; losClass = "los-e"; }
        else if (vcRatio > 0.75) { los = "D"; losClass = "los-d"; }
        else if (vcRatio > 0.55) { los = "C"; losClass = "los-c"; }
        else if (vcRatio > 0.35) { los = "B"; losClass = "los-b"; }

        // 5. Update Results UI
        document.getElementById('res_fut_aadt').innerText = Math.round(futureAadt).toLocaleString();
        document.getElementById('res_dhv').innerText = Math.round(dhv).toLocaleString() + " veh/hr";
        document.getElementById('res_vc').innerText = vcRatio.toFixed(2);
        
        const losEl = document.getElementById('res_los');
        losEl.innerText = los;
        losEl.className = ""; // clear old classes
        losEl.classList.add(losClass); // add color class
        losEl.style.padding = "5px 10px";
        losEl.style.borderRadius = "4px";

        // 6. Queue Blockage Calculation (Deterministic)
        // How many vehicles arrive per lane in X minutes?
        const vehPerMin = volPerLane / 60;
        
        // Average vehicle length (7m car, 12.5m truck approx + gaps)
        // Weighted avg length
        const avgLen = (1 - hv) * 7.0 + (hv * 13.0); 

        let html = "";
        // Calculate for 1, 2, 3... 15 minutes blockage
        [1, 2, 3, 5, 10, 15].forEach(min => {
            const vehicles = vehPerMin * min;
            const qLen = vehicles * avgLen; 
            html += `
            <tr>
                <td>${min} min</td>
                <td><strong>${Math.round(qLen)}</strong> m</td>
            </tr>
        `;
        });
        document.getElementById('aadt_queue_table').innerHTML = html;
    }

    // --- NEW TIA & MAP LOGIC ---

    // 1. TIA Calculation Function (Matches Excel Logic)
    function calculateTIA() {
        // Inputs
        const curAADT = parseFloat(document.getElementById('tia_aadt').value) || 0;
        const yearData = parseFloat(document.getElementById('tia_year_data').value);
        const yearOpen = parseFloat(document.getElementById('tia_year_open').value);
        const growth = parseFloat(document.getElementById('tia_growth').value);
        const lanes = parseFloat(document.getElementById('tia_lanes').value);
        const capTotal = parseFloat(document.getElementById('tia_capacity').value);
        const hv = parseFloat(document.getElementById('tia_hv').value);
        
        // 1. Calculate Future AADT (Compound Growth)
        const years = yearOpen - yearData;
        const futureAADT = curAADT * Math.pow((1 + growth / 100), years);
        
        // 2. Design Hourly Volume (Approx 10% of AADT or 80th Highest logic)
        // Note: Excel uses specific peak counts, here we estimate using K=0.1 if not provided
        // For accurate TIA, we usually take 10% of AADT as Design Hour if raw data isn't loaded
        const kFactor = 0.1; 
        const dirSplit = 0.6; // Assuming 60% peak direction like Excel
        const designVol = futureAADT * kFactor * dirSplit; 

        // 3. VCR Calculation
        const vcr = designVol / capTotal;

        // 4. LOS Logic (from Excel CSV)
        let los = "F";
        let losClass = "los-f";
        if (vcr <= 0.60) { los = "A"; losClass = "los-a"; }
        else if (vcr <= 0.70) { los = "B"; losClass = "los-b"; }
        else if (vcr <= 0.90) { los = "C"; losClass = "los-c"; }
        else if (vcr <= 0.95) { los = "D"; losClass = "los-d"; }
        else if (vcr <= 1.00) { los = "E"; losClass = "los-e"; }

        // 5. Update TIA Results
        document.getElementById('tia_res_aadt').innerText = Math.round(futureAADT).toLocaleString();
        document.getElementById('tia_res_vol').innerText = Math.round(designVol).toLocaleString();
        document.getElementById('tia_res_vcr').innerText = vcr.toFixed(3);
        
        const badge = document.getElementById('tia_res_los_badge');
        badge.innerText = "LOS " + los;
        badge.className = "";
        badge.classList.add(losClass);
        badge.style.padding = "5px 10px"; badge.style.borderRadius = "4px"; badge.style.fontWeight = "bold";

        // 6. Queue Calculation (Excel Multiplier Logic)
        // Vol per 5 mins per lane
        const hourlyPerLane = designVol / lanes;
        const vol5min = hourlyPerLane / 12; 
        
        // Weighted Average Vehicle Length (Excel implies variation, we use standard logic)
        // (1-HV)*7m + HV*13m
        const avgLen = ((100 - hv)/100 * 7.0) + (hv/100 * 13.0);

        // Multipliers from Excel TIA
        let queue5mMeters = 0;
        const multipliers = [
            { id: 'q_2m', m: 2.4 },
            { id: 'q_5m', m: 6.0 },
            { id: 'q_10m', m: 12.0 },
            { id: 'q_15m', m: 18.0 },
            { id: 'q_30m', m: 36.0 }
        ];

        multipliers.forEach(item => {
            // Formula: Vol_5min * Multiplier * (Length/Standard_Length_Adjustment)
            // Note: The Excel multiplier (e.g. 6.0 for 5min) implicitly includes time factor
            // We multiply by avgLen to get meters. 
            // We apply a CV safety factor of 1.05 as observed in your sheets.
            const safetyFactor = 1.05; 
            const queue = vol5min * item.m * (avgLen / 6) * safetyFactor; // Adjusted to match sample data
            
            // Or simpler direct logic based on your Excel:
            // Q = (Vehicles_In_Duration) * AvgLen
            // Vehicles = (hourlyPerLane / 60) * duration
            // Let's use the explicit Multiplier from Excel which seems to govern it
            // Heuristic:
            const qCalc = vol5min * item.m; // This gives "Vehicles" roughly
            const qMeters = qCalc * avgLen;

            if (item.id === 'q_5m') {
                queue5mMeters = qMeters;
            }
            
            document.getElementById(item.id).innerText = Math.round(qMeters).toLocaleString();
        });

        updateTiaQueueOverlay(queue5mMeters);
    }

    // 2. Map & Embedded GeoJSON Loader
    let map;
    let embeddedGeoLayer;
    let gcSiteLayers = {};
    let selectedGcSiteId = null;
    let tiaSelectedLatLng = null;
    let tiaQueueOverlay = null;

    // ===== CONFIGURATION: External GeoJSON URL =====
    // To use Google Drive:
    // 1. Upload Gold Coast GeoJSON to Google Drive
    // 2. Right-click ‚Üí Share ‚Üí Change to "Anyone with the link"
    // 3. Copy the share link (e.g., https://drive.google.com/file/d/FILE_ID/view?usp=sharing)
    // 4. Convert to direct download link: https://drive.google.com/uc?export=download&id=FILE_ID
    // ================================================
    // Gold Coast GeoJSON - Loaded from separate GitHub file
    // ================================================

    async function getEmbeddedGeoJSON() { 
        // Use GitHub Gold Coast data (separate file)
        return await getGitHubGeoJSON();
    }

    function renderGeoJSONOnMap(geoData) {
        if (embeddedGeoLayer) {
            map.removeLayer(embeddedGeoLayer);
        }

        gcSiteLayers = {};
        selectedGcSiteId = null;

        embeddedGeoLayer = L.geoJSON(geoData, {
            pointToLayer: function (feature, latlng) {
                return L.circleMarker(latlng, {
                    radius: 6,
                    fillColor: "#ff7800",
                    color: "#000",
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                });
            },
            onEachFeature: function (feature, layer) {
                const props = feature.properties || {};
                const siteId = props.OBJECTID || props.id || feature.id || "N/A";
                const vpdRaw = props.VPD ?? props.ADT ?? props.AADT;
                const vpdValue = Number.isFinite(Number(vpdRaw)) ? Number(vpdRaw) : null;
                const vpdLabel = vpdValue !== null ? vpdValue : "N/A";
                const street = props.STREET || props.Road_Name || props.ROAD_NAME || "Unknown St";
                const loc = props.LOCATION || props.SITE_LOCATION || "";
                const surveyDate = props.SURVEY_DATE || props.SURVEYDATE || props.SURVEY_YEAR || props.COUNT_YEAR || props.COUNTYEAR || props.YEAR;
                const surveyYear = extractSurveyYear(surveyDate);
                const surveyLabel = surveyYear ? surveyYear : "N/A";

                layer.bindPopup(`
                    <strong>Site ID: ${siteId}</strong><br>
                    <strong>${street}</strong><br>
                    Loc: ${loc}<br>
                    VPD: ${vpdLabel}<br>
                    Count Year: ${surveyLabel}<br>
                    <button onclick="fillTIA('${siteId}', '${street}', ${vpdValue}, ${surveyYear || 'null'})" style="background-color: #4CAF50; color: white; padding: 5px 10px; border: none; border-radius: 3px; cursor: pointer; margin-top: 5px;">Use in TIA</button>
                `);

                gcSiteLayers[String(siteId)] = layer;
            }
        }).addTo(map);
    }

    function highlightGcSite(siteId) {
        if (selectedGcSiteId && gcSiteLayers[selectedGcSiteId]) {
            gcSiteLayers[selectedGcSiteId].setStyle({
                radius: 6,
                fillColor: "#ff7800",
                color: "#000",
                weight: 1,
                opacity: 1,
                fillOpacity: 0.8
            });
        }

        const targetId = String(siteId);
        const layer = gcSiteLayers[targetId];
        if (!layer) return;

        selectedGcSiteId = targetId;
        layer.setStyle({
            radius: 9,
            fillColor: "#0056b3",
            color: "#003366",
            weight: 2,
            opacity: 1,
            fillOpacity: 0.95
        });
        layer.openPopup();
    }

    function clearTiaQueueOverlay() {
        if (map && tiaQueueOverlay) {
            map.removeLayer(tiaQueueOverlay);
            tiaQueueOverlay = null;
        }
    }

    function offsetLatLng(lat, lng, meters, bearingDeg) {
        const R = 6378137;
        const bearing = (bearingDeg * Math.PI) / 180;
        const lat1 = (lat * Math.PI) / 180;
        const lon1 = (lng * Math.PI) / 180;
        const dr = meters / R;

        const lat2 = Math.asin(
            Math.sin(lat1) * Math.cos(dr) +
            Math.cos(lat1) * Math.sin(dr) * Math.cos(bearing)
        );
        const lon2 = lon1 + Math.atan2(
            Math.sin(bearing) * Math.sin(dr) * Math.cos(lat1),
            Math.cos(dr) - Math.sin(lat1) * Math.sin(lat2)
        );

        return {
            lat: (lat2 * 180) / Math.PI,
            lng: (lon2 * 180) / Math.PI
        };
    }

    function updateTiaQueueOverlay(queueMeters) {
        const status = document.getElementById('tiaQueueMapStatus');
        if (!map || !tiaSelectedLatLng) {
            if (status) {
                status.textContent = 'Select a site and run TIA to show the 5-min queue indicator on the map.';
            }
            return;
        }

        const queueLen = Math.max(0, Number(queueMeters) || 0);
        clearTiaQueueOverlay();

        const start = tiaSelectedLatLng;
        const end = offsetLatLng(start.lat, start.lng, queueLen, 90);

        const line = L.polyline([start, end], {
            color: '#d36b2c',
            weight: 5,
            opacity: 0.85,
            dashArray: '8 6'
        });

        const endMarker = L.circleMarker(end, {
            radius: 6,
            color: '#d36b2c',
            fillColor: '#d36b2c',
            fillOpacity: 0.9
        });

        tiaQueueOverlay = L.layerGroup([line, endMarker]).addTo(map);

        if (status) {
            status.textContent = `Queue indicator shown on map (5 min = ${Math.round(queueLen)} m).`;
        }
    }

    async function loadEmbeddedGeoJSON() {
        try {
            initMap();
            const geoData = await getEmbeddedGeoJSON();
            renderGeoJSONOnMap(geoData);
        } catch (err) {
            console.error('Failed to load embedded GeoJSON:', err);
            alert('Failed to load embedded Gold Coast GeoJSON: ' + err.message);
        }
    }

    function initMap() {
        if(map) return; // already initialized
        // Center on Gold Coast
        map = L.map('interactiveMap').setView([-28.00, 153.40], 11);
        
        // Add OpenStreetMap tiles
        addTileLayerWithFallback(
            map,
            'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            { attribution: '&copy; OpenStreetMap contributors' },
            'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
            { attribution: '&copy; OpenStreetMap contributors &copy; CARTO' }
        );
    }

    // Helper to fill TIA form from Gold Coast Map
    function extractSurveyYear(value) {
        if (!value) return null;
        if (typeof value === 'number' && Number.isFinite(value)) return value;
        const text = String(value);
        const match = text.match(/\b(19|20)\d{2}\b/);
        if (match) return Number(match[0]);
        const parsed = new Date(text);
        if (!Number.isNaN(parsed.getTime())) return parsed.getFullYear();
        return null;
    }

    window.fillTIA = function(siteId, street, vpd, surveyYear) {
        document.getElementById('tia_project').value = `Site ${siteId} - ${street}`;
        if (Number.isFinite(Number(vpd))) {
            document.getElementById('tia_aadt').value = vpd;
        }
        if (Number.isFinite(Number(surveyYear))) {
            document.getElementById('tia_year_data').value = surveyYear;
        }
        const layer = gcSiteLayers[String(siteId)];
        if (layer && typeof layer.getLatLng === 'function') {
            tiaSelectedLatLng = layer.getLatLng();
        }
        // Switch tab
        document.querySelector("button[onclick*='tab-tia']").click();

        const aadtInput = document.getElementById('tia_aadt');
        if (aadtInput) {
            aadtInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
            aadtInput.focus();
            aadtInput.style.transition = 'background-color 0.3s';
            aadtInput.style.backgroundColor = '#ffffcc';
            setTimeout(() => {
                aadtInput.style.backgroundColor = '';
            }, 1000);
        }
    };

    // Helper to fill TIA form from TMR site data
    window.fillTIAFromTMR = function(siteId) {
        const site = sitesData[siteId];
        if (!site) {
            alert('Site data not found');
            return;
        }

        // Calculate AADT from hourly data
        const gazData = site.directions['GAZETTAL'] || new Array(24).fill(0);
        const agData = site.directions['AGAINST GAZETTAL'] || new Array(24).fill(0);
        
        // Sum both directions for total daily volume
        const totalDaily = gazData.reduce((sum, val) => sum + val, 0) + 
                          agData.reduce((sum, val) => sum + val, 0);
        
        // AADT is essentially the daily total (already represents an average day)
        const aadt = Math.round(totalDaily);

        // Fill TIA form
        document.getElementById('tia_project').value = `${siteId} - ${site.road_name || 'TMR Site'}`;
        document.getElementById('tia_aadt').value = aadt;
        
        // Optional: set year if available in data, otherwise keep default
        // document.getElementById('tia_year_data').value = 2020; // Could be extracted from data
        
        // Show confirmation (data saved, stay on TMR tab)
        alert(`TMR site "${siteId}" data saved to TIA\n\nCalculated AADT: ${aadt.toLocaleString()} vehicles/day\n\nSwitch to "Gold coast" tab to use this data in TIA analysis.`);
    };

    // Initialize maps when tabs are clicked (optimized with lazy loading)
    let goldCoastMapInitialized = false;
    let ipswichMapInitialized = false;
    let loganMapInitialized = false;
    let tmrMapInitialized = false;
    
    const originalOpenTab = window.openTab;
    window.openTab = function(evt, tabName) {
        // Optimized tab switching
        const tabcontent = document.getElementsByClassName("tab-content");
        const tablinks = document.getElementsByClassName("tab-button");
        
        for (let i = 0; i < tabcontent.length; i++) {
            tabcontent[i].classList.remove("active");
        }
        for (let i = 0; i < tablinks.length; i++) {
            tablinks[i].classList.remove("active");
        }
        
        document.getElementById(tabName).classList.add("active");
        if(evt) evt.currentTarget.classList.add("active");

        // Lazy initialize maps only when needed
        if(tabName === 'tab-tia' && !goldCoastMapInitialized) {
            goldCoastMapInitialized = true;
            setTimeout(loadEmbeddedGeoJSON, 100);
        } else if (tabName === 'tab-tia' && map) {
            map.invalidateSize();
        }
        
        if (tabName === 'tab-hourly' && hourlyMap) {
            hourlyMap.invalidateSize();
        }

        if (tabName === 'Ipswich') {
            if (!ipswichMapInitialized) {
                ipswichMapInitialized = true;
                initIpswich();
            } else if (ipswichMapInstance) {
                ipswichMapInstance.invalidateSize();
            }
        }

        if (tabName === 'Logan') {
            if (!loganMapInitialized) {
                loganMapInitialized = true;
                initLogan();
            } else if (loganMapInstance) {
                loganMapInstance.invalidateSize();
            }
        }
    };
</script>
<!-- Gold Coast GeoJSON Data loaded from GitHub -->
<script>
    // Global variable to store Gold Coast data for searching
    window.goldCoastDataRaw = null;

    // 1. Modify the existing loadEmbeddedGeoJSON to save data globally
    const originalLoadGeo = window.loadEmbeddedGeoJSON;
    window.loadEmbeddedGeoJSON = async function() {
        try {
            initMap();
            const geoData = await getEmbeddedGeoJSON();
            window.goldCoastDataRaw = geoData; // Store globally for search
            renderGeoJSONOnMap(geoData);
        } catch (err) {
            console.error("Error storing GC data", err);
        }
    };

    // 2. UI Functions
    function closeLandingPage() {
        document.getElementById('landingPage').classList.add('hidden-overlay');
    }

    function handleEnter(e) {
        if(e.key === 'Enter') executeSmartSearch();
    }

    function updateStatus(msg) {
        document.getElementById('searchStatus').textContent = msg;
    }

    function safeParseJson(rawText) {
        // Some datasets contain unquoted NaN values, which break JSON.parse.
        const sanitized = rawText.replace(/\bNaN\b/g, 'null');
        return JSON.parse(sanitized);
    }

    async function ensureSearchDataLoaded() {
        if (!window.goldCoastDataRaw) await window.loadEmbeddedGeoJSON();

        if (typeof ipswichDataGlobal === 'undefined' || !ipswichDataGlobal) {
            try {
                console.log('Loading Ipswich data...');
                const response = await fetch('https://raw.githubusercontent.com/crsanju/Cromton_Traffic_Analysis/main/Ipswich.geojson');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const rawText = await response.text();
                ipswichDataGlobal = safeParseJson(rawText);
         
                console.log('‚úì Ipswich data loaded');
            } catch (error) {
                console.error('‚úó Failed to load Ipswich data:', error);
            }
        }

        if (typeof loganDataGlobal === 'undefined' || !loganDataGlobal) {
            try {
                const url = 'https://raw.githubusercontent.com/crsanju/Cromton_Traffic_Analysis/main/logan.geojson';
                console.log('Loading Logan data from:', url);
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: File not found at ${url}`);
                }
                loganDataGlobal = await response.json();
                console.log('‚úì Logan data loaded successfully:', loganDataGlobal.features ? loganDataGlobal.features.length : 0, 'features');
            } catch (error) {
                console.error('‚úó Failed to load Logan data:', error);
                console.warn('Using empty Logan dataset as fallback');
                loganDataGlobal = { type: 'FeatureCollection', features: [] };
            }
        }
    }

    // 3. Main Search Logic
    const MAPS_CO_API_KEY = '';
    const IS_FILE_ORIGIN = window.location.protocol === 'file:';
    const HOUSEHOLD_TRIP_RATE = 2.5 * 4.5;

    function normalizeSearchQuery(raw) {
        return String(raw || '')
            .replace(/\s+/g, ' ')
            .trim();
    }

    function parseCoordinates(raw) {
        const text = normalizeSearchQuery(raw);
        const match = text.match(/^(-?\d+(?:\.\d+)?)[,;\s]+(-?\d+(?:\.\d+)?)$/);
        if (!match) return null;

        const lat = parseFloat(match[1]);
        const lon = parseFloat(match[2]);
        if (Number.isNaN(lat) || Number.isNaN(lon)) return null;
        if (lat < -90 || lat > 90 || lon < -180 || lon > 180) return null;
        return { lat, lon, roadName: null };
    }

    async function geocodeWithNominatim(query) {
        try {
            if (IS_FILE_ORIGIN) return null;
            const url = `https://nominatim.openstreetmap.org/search?format=jsonv2&limit=5&addressdetails=1&countrycodes=au&q=${encodeURIComponent(query)}`;
            const response = await fetch(url, {
                headers: {
                    'Accept-Language': 'en-AU,en;q=0.9'
                }
            });

            if (!response.ok) return null;
            const data = await response.json();
            if (!Array.isArray(data) || data.length === 0) return null;

            const address = data[0].address || {};
            const roadName = address.road || address.pedestrian || address.footway || address.cycleway || address.neighbourhood || null;
            return {
                lat: parseFloat(data[0].lat),
                lon: parseFloat(data[0].lon),
                roadName: roadName
            };
        } catch (error) {
            console.warn('Nominatim geocoding failed:', error);
            return null;
        }
    }

    async function geocodeWithMapsCo(query) {
        try {
            if (!MAPS_CO_API_KEY) return null;
            const url = `https://geocode.maps.co/search?q=${encodeURIComponent(query)}&country=au&api_key=${encodeURIComponent(MAPS_CO_API_KEY)}`;
            const response = await fetch(url);
            if (!response.ok) return null;
            const data = await response.json();
            if (!Array.isArray(data) || data.length === 0) return null;
            const address = data[0].address || {};
            const roadName = address.road || address.pedestrian || address.neighbourhood || null;
            return {
                lat: parseFloat(data[0].lat),
                lon: parseFloat(data[0].lon),
                roadName: roadName
            };
        } catch (error) {
            console.warn('Maps.co geocoding failed:', error);
            return null;
        }
    }

    async function geocodeWithPhoton(query) {
        try {
            const url = `https://photon.komoot.io/api/?q=${encodeURIComponent(query)}&limit=5&lang=en&lat=-27.4698&lon=153.0251`;
            const response = await fetch(url);
            if (!response.ok) return null;
            const data = await response.json();
            const feature = data && data.features && data.features[0];
            const coords = feature && feature.geometry && feature.geometry.coordinates;
            if (!coords || coords.length < 2) return null;
            const props = feature.properties || {};
            const roadName = props.street || props.name || props.locality || null;
            return { lat: coords[1], lon: coords[0], roadName: roadName };
        } catch (error) {
            console.warn('Photon geocoding failed:', error);
            return null;
        }
    }

    async function geocodeLocation(query) {
        const normalized = normalizeSearchQuery(query);
        if (!normalized) return null;

        const directCoords = parseCoordinates(normalized);
        if (directCoords) return directCoords;

        const photon = await geocodeWithPhoton(`${normalized} Australia`);
        if (photon) return photon;

        const mapsCo = await geocodeWithMapsCo(`${normalized} Australia`);
        if (mapsCo) return mapsCo;

        const nominatim = await geocodeWithNominatim(`${normalized} Australia`);
        if (nominatim) return nominatim;

        return await geocodeWithPhoton(`${normalized} Australia`);
    }

    async function executeSmartSearch() {
        const query = document.getElementById('landingSearchInput').value;
        if (!normalizeSearchQuery(query)) return updateStatus("Please enter a location.");

        updateStatus("üîç Locating...");

        try {
            const coords = await geocodeLocation(query);

            if (!coords) {
                return updateStatus("‚ùå Location not found. Try a broader search or add suburb/state.");
            }

            updateStatus("üìç Location found. Finding nearest traffic site...");

            // Ensure data is loaded
            await ensureSearchDataLoaded();

            findNearestAndRedirect(coords.lat, coords.lon, coords.roadName);

        } catch (error) {
            console.error(error);
            const message = error && error.message ? error.message : 'Unknown error';
            updateStatus(`‚ö†Ô∏è Search failed: ${message}`);
        }
    }

    function useCurrentLocation() {
        if (!navigator.geolocation) return updateStatus("Geolocation not supported by your browser.");
        
        updateStatus("üõ∞Ô∏è Acquiring GPS...");
        navigator.geolocation.getCurrentPosition(
            async (position) => {
                await ensureSearchDataLoaded();
                findNearestAndRedirect(position.coords.latitude, position.coords.longitude);
            },
            () => {
                updateStatus("‚ö†Ô∏è Unable to retrieve your location.");
            }
        );
    }

    // 4. Distance Calculation (Haversine)
    function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {
        var R = 6371; // Radius of the earth in km
        var dLat = deg2rad(lat2-lat1);
        var dLon = deg2rad(lon2-lon1); 
        var a = 
            Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat1)) * Math.sin(dLon/2) * Math.sin(dLon/2); 
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
        var d = R * c; 
        return d;
    }

    function deg2rad(deg) { return deg * (Math.PI/180); }

    // 5. Nearest Neighbor Logic
    function normalizeRoadName(value) {
        return String(value || '')
            .replace(/[^a-z0-9\s]/gi, ' ')
            .replace(/\s+/g, ' ')
            .trim()
            .toLowerCase();
    }

    function roadMatches(queryRoad, candidateRoad) {
        const query = normalizeRoadName(queryRoad);
        const candidate = normalizeRoadName(candidateRoad);
        if (!query || !candidate) return false;
        return candidate.includes(query) || query.includes(candidate);
    }

    function getSiteRoadName(sourceType, nearestSite) {
        if (!nearestSite) return '';
        if (sourceType === 'TMR') {
            return nearestSite.road_name || nearestSite.description || '';
        }
        const props = nearestSite.properties || {};
        if (sourceType === 'GC') {
            return props.STREET || props.Road_Name || props.ROAD_NAME || props.Location || '';
        }
        if (sourceType === 'IPSWICH') {
            return props["Road Name"] || props.Description || props.ROAD_NAME || props.Road_Name || props.STREET || props.Location || props.SITE_LOCATION || '';
        }
        if (sourceType === 'LOGAN') {
            return props.STREET_NAME || props.RoadName || props.ROAD_NAME || props.STREET || props.COUNTER_LOCATION_BETWEEN || props.COMMENTS || '';
        }
        return '';
    }

    function getSiteAadt(sourceType, nearestSite) {
        if (!nearestSite) return 0;
        if (sourceType === 'TMR') {
            const gazData = nearestSite.directions && nearestSite.directions['GAZETTAL'] ? nearestSite.directions['GAZETTAL'] : [];
            const agData = nearestSite.directions && nearestSite.directions['AGAINST GAZETTAL'] ? nearestSite.directions['AGAINST GAZETTAL'] : [];
            const totalDaily = gazData.reduce((sum, val) => sum + (Number(val) || 0), 0) +
                agData.reduce((sum, val) => sum + (Number(val) || 0), 0);
            return Math.round(totalDaily);
        }

        const props = nearestSite.properties || {};
        if (sourceType === 'GC') {
            const vpdRaw = props.VPD ?? props.ADT ?? props.AADT;
            return Number.isFinite(Number(vpdRaw)) ? Number(vpdRaw) : 0;
        }
        if (sourceType === 'IPSWICH') {
            let aadt = props["Average Daily Traffic Adt Vehicles Per Day"] || props.ADT || props.AADT || 0;
            if (!aadt || aadt === 0) {
                const am = props["Weekday Avg AM Peak Flow Vehicles Per Hour"] || 0;
                const pm = props["Weekday Avg PM Peak Flow Vehicles Per Hour"] || 0;
                const maxPeak = Math.max(am, pm);
                if (maxPeak > 0) aadt = maxPeak * 10;
            }
            return Number(aadt) || 0;
        }
        if (sourceType === 'LOGAN') {
            let aadt = props.AADT ?? props.ADT ?? props.AAWT ?? props.Volume;
            if (aadt == null || isNaN(aadt)) {
                const vol1 = Number(props.VOL1 || 0);
                const vol2 = Number(props.VOL2 || 0);
                aadt = (isNaN(vol1) ? 0 : vol1) + (isNaN(vol2) ? 0 : vol2);
            }
            return Number(aadt) || 0;
        }
        return 0;
    }

    let mismatchContext = null;

    function showMismatchPanel(queryRoadName, sourceType, nearestSite) {
        if (!queryRoadName) return false;
        const siteRoad = getSiteRoadName(sourceType, nearestSite);
        if (!siteRoad) return false;
        if (roadMatches(queryRoadName, siteRoad)) return false;

        mismatchContext = {
            queryRoadName: queryRoadName,
            sourceType: sourceType,
            nearestSite: nearestSite,
            baseAadt: getSiteAadt(sourceType, nearestSite),
            siteRoad: siteRoad
        };

        const summary = document.getElementById('mismatchSummary');
        summary.textContent = `"${queryRoadName}" is not in the database. Nearest known road: ${siteRoad}.`;

        document.getElementById('mismatchPercent').value = 100;
        document.getElementById('mismatchHouseholds').value = 0;
        document.getElementById('mismatchResult').textContent = '';

        document.getElementById('mismatchPanel').classList.remove('hidden-overlay');
        return true;
    }

    function closeMismatchPanel() {
        document.getElementById('mismatchPanel').classList.add('hidden-overlay');
        mismatchContext = null;
    }

    function applyMismatchInputs() {
        if (!mismatchContext) return;

        let percent = parseFloat(document.getElementById('mismatchPercent').value);
        if (!Number.isFinite(percent) || percent < 0) percent = 100;

        let households = parseFloat(document.getElementById('mismatchHouseholds').value);
        if (!Number.isFinite(households) || households < 0) households = 0;

        const percentAadt = mismatchContext.baseAadt * (percent / 100);
        const manualAadt = households * HOUSEHOLD_TRIP_RATE;
        const chosenAadt = Math.max(percentAadt, manualAadt);

        if (Math.abs(percentAadt - manualAadt) > 500) {
            document.getElementById('mismatchResult').textContent = 'Warning: Difference between AADT and manual calculation is greater than 500.';
        } else {
            document.getElementById('mismatchResult').textContent = '';
        }

        closeMismatchPanel();
        closeLandingPage();

        document.querySelector("button[onclick*='tab-aadt']").click();
        const aadtInput = document.getElementById('aadt_val');
        if (aadtInput) {
            aadtInput.value = Math.round(chosenAadt);
        }
        calculateAADTLogic();
    }

    function findNearestAndRedirect(targetLat, targetLon, queryRoadName) {
        let nearestSite = null;
        let minDistance = Infinity;
        let sourceType = ''; // 'TMR' or 'GC'

        // A. Search TMR Data (sitesData global variable)
        const tmrEntries = Object.entries(sitesData);
        for (const [id, site] of tmrEntries) {
            if (site.latitude && site.longitude) {
                const dist = getDistanceFromLatLonInKm(targetLat, targetLon, site.latitude, site.longitude);
                if (dist < minDistance) {
                    minDistance = dist;
                    nearestSite = { id: id, ...site };
                    sourceType = 'TMR';
                }
            }
        }

        // B. Search Gold Coast Data (window.goldCoastDataRaw)
        if (window.goldCoastDataRaw && window.goldCoastDataRaw.features) {
            window.goldCoastDataRaw.features.forEach(feature => {
                const geometry = feature && feature.geometry;
                const coords = geometry && Array.isArray(geometry.coordinates) ? geometry.coordinates : null;
                if (!coords || coords.length < 2) return;

                // GeoJSON uses [Long, Lat]
                const dist = getDistanceFromLatLonInKm(targetLat, targetLon, coords[1], coords[0]);
                
                if (dist < minDistance) {
                    minDistance = dist;
                    nearestSite = feature;
                    sourceType = 'GC';
                }
            });
        }

        // C. Search Ipswich Data
        if (typeof ipswichDataGlobal !== 'undefined' && ipswichDataGlobal && ipswichDataGlobal.features) {
            ipswichDataGlobal.features.forEach(feature => {
                const coords = feature.geometry && feature.geometry.coordinates;
                if (coords) {
                    const dist = getDistanceFromLatLonInKm(targetLat, targetLon, coords[1], coords[0]);
                    if (dist < minDistance) {
                        minDistance = dist;
                        nearestSite = feature;
                        sourceType = 'IPSWICH';
                    }
                }
            });
        }

        // D. Search Logan Data
        if (typeof loganDataGlobal !== 'undefined' && loganDataGlobal && loganDataGlobal.features) {
            loganDataGlobal.features.forEach(feature => {
                const geometry = feature && feature.geometry;
                const coords = geometry && Array.isArray(geometry.coordinates) ? geometry.coordinates : null;
                if (!coords || coords.length < 2) return;

                const dist = getDistanceFromLatLonInKm(targetLat, targetLon, coords[1], coords[0]);
                if (dist < minDistance) {
                    minDistance = dist;
                    nearestSite = feature;
                    sourceType = 'LOGAN';
                }
            });
        }

        // C. Redirect User
        if (nearestSite) {
            if (showMismatchPanel(queryRoadName, sourceType, nearestSite)) {
                return;
            }

            closeLandingPage();
            
            if (sourceType === 'TMR') {
                // Switch to TMR Tab
                document.querySelector("button[onclick*='tab-hourly']").click();
                
                // Use existing function to select site
                // Adding a small delay to ensure tab visibility
                setTimeout(() => {
                    selectSiteFromMap(nearestSite.id);
                    if (hourlyMap && nearestSite.latitude && nearestSite.longitude) {
                        hourlyMap.setView([nearestSite.latitude, nearestSite.longitude], 15);
                        highlightHourlyMarker(nearestSite.id);
                    }
                    alert(`Nearest Site Found (${minDistance.toFixed(2)}km away):\n${nearestSite.id} - ${nearestSite.road_name}`);
                }, 500);

            } else if (sourceType === 'GC') {
                // Switch to GC/TIA Tab
                const props = nearestSite.properties;
                const siteId = props.OBJECTID || props.id;
                const street = props.STREET || props.Road_Name || "Unknown";
                const vpd = props.VPD || props.ADT || props.AADT || 0;
                
                // Need to extract year logic similar to render function
                let year = 2020; // default
                const dateStr = props.SURVEY_DATE || props.SURVEYDATE || props.YEAR;
                if(dateStr) {
                    const match = String(dateStr).match(/\b(19|20)\d{2}\b/);
                    if(match) year = Number(match[0]);
                }

                document.querySelector("button[onclick*='tab-tia']").click();

                setTimeout(() => {
                    fillTIA(siteId, street, vpd, year);
                    alert(`Nearest Site Found (${minDistance.toFixed(2)}km away):\nGold Coast Site: ${street}`);
                    
                    // Center map on the site
                    if(map && nearestSite.geometry && Array.isArray(nearestSite.geometry.coordinates)) {
                        const coords = nearestSite.geometry.coordinates;
                        if (coords.length >= 2) {
                            map.setView([coords[1], coords[0]], 15);
                        }
                    }

                    highlightGcSite(siteId);
                }, 500);
            } else if (sourceType === 'IPSWICH') {
                document.querySelector("button[onclick*='Ipswich']").click();

                setTimeout(() => {
                    const props = nearestSite.properties || {};
                    const id = props.Site || props.SITE || props.OBJECTID || props.id || nearestSite.id;
                    const name = props.Description || props.ROAD_NAME || props.Road_Name || props.STREET || props.Location || props.SITE_LOCATION || 'Ipswich Site';
                    selectIpswichSite(id);
                    alert(`Nearest Site Found (${minDistance.toFixed(2)}km away):\nIpswich: ${name}`);
                }, 500);
            } else if (sourceType === 'LOGAN') {
                document.querySelector("button[onclick*='Logan']").click();

                setTimeout(() => {
                    const props = nearestSite.properties || {};
                    const id = props.OBJECTID || props.SiteID;
                    selectLoganSite(id);
                    const name = props.STREET_NAME || props.RoadName || props.ROAD_NAME || props.STREET || props.COUNTER_LOCATION_BETWEEN || 'Logan Site';
                    alert(`Nearest Site Found (${minDistance.toFixed(2)}km away):\nLogan: ${name}`);
                }, 500);
            }
        } else {
            updateStatus("‚ùå No traffic sites found in database.");
        }
    }

    // --- IPSWICH MODULE (Updated with Excel Logic) ---

    let ipswichDataGlobal = [];
    let ipswichLayerGroup = L.layerGroup();
    let ipswichMapInstance = null;

    async function initIpswich() {
        if (!ipswichMapInstance) {
            ipswichMapInstance = L.map('ipswichMap').setView([-27.6144, 152.7608], 12);
            addTileLayerWithFallback(
                ipswichMapInstance,
                'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                { attribution: '&copy; OpenStreetMap contributors' },
                'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
                { attribution: '&copy; OpenStreetMap contributors &copy; CARTO' }
            );
        }

        if (ipswichDataGlobal.length === 0) {
            try {
                const response = await fetch('https://raw.githubusercontent.com/crsanju/Cromton_Traffic_Analysis/refs/heads/main/Ipswich.geojson');
                const rawText = await response.text();
                const parsed = safeParseJson(rawText);
                ipswichDataGlobal = parsed.features ? parsed.features : parsed;

                populateIpswichMap();
                populateIpswichList();
            } catch (error) {
                console.error("Error loading Ipswich data:", error);
            }
        }
        setTimeout(() => { ipswichMapInstance.invalidateSize(); }, 200);
    }

    function populateIpswichMap() {
        ipswichLayerGroup.clearLayers();
        
        ipswichDataGlobal.forEach(item => {
            // Normalize properties whether it's GeoJSON or flat JSON
            const p = item.properties || item; 
            const geom = item.geometry;
            
            let lat, lon;
            if (geom && geom.coordinates) {
                // GeoJSON is [Lon, Lat]
                lon = geom.coordinates[0];
                lat = geom.coordinates[1];
            } else {
                // Flat JSON fallback
                lat = p["GPS Latitude"] || p.Latitude || p.lat;
                lon = p["GPS Longitude"] || p.Longitude || p.lon;
            }

            if (lat && lon) {
                const name = p["Road Name"] || p.Description || p.ROAD_NAME || p.Road_Name || p.STREET || p.Location || p.SITE_LOCATION || "Unknown";
                const id = p["Id"] || p.ID || p.Site || p.SITE || p.OBJECTID || "0";

                const marker = L.circleMarker([lat, lon], {
                    radius: 6, fillColor: "#d35400", color: "#fff", weight: 1, fillOpacity: 0.8
                });
                
                // Store full data in marker for easy retrieval
                marker.siteData = p; 

                marker.bindPopup(`<b>${name}</b><br>ID: ${id}<br><button onclick="selectIpswichSite('${id}')">Analyze</button>`);
                marker.on('click', () => selectIpswichSite(id));
                ipswichLayerGroup.addLayer(marker);
            }
        });
        ipswichLayerGroup.addTo(ipswichMapInstance);
    }

    function populateIpswichList() {
        const select = document.getElementById('ipswichSiteSelect');
        select.innerHTML = "";
        // Sort by name
        const list = [...ipswichDataGlobal].sort((a, b) => {
            const na = (a.properties || a)["Road Name"] || (a.properties || a).Description || (a.properties || a).ROAD_NAME || "";
            const nb = (b.properties || b)["Road Name"] || (b.properties || b).Description || (b.properties || b).ROAD_NAME || "";
            return na.localeCompare(nb);
        });

        list.forEach(item => {
            const p = item.properties || item;
            const name = p["Road Name"] || p.Description || p.ROAD_NAME || p.Road_Name || p.STREET || p.Location || p.SITE_LOCATION;
            const id = p["Id"] || p.ID || p.Site || p.SITE || p.OBJECTID;
            const opt = document.createElement("option");
            opt.value = id;
            opt.innerText = `${name} (${id})`;
            select.appendChild(opt);
        });
    }

    function filterIpswichList() {
        const query = document.getElementById('ipswichSearch').value.toLowerCase();
        const select = document.getElementById('ipswichSiteSelect');
        select.innerHTML = "";

        ipswichDataGlobal.filter(item => {
            const p = item.properties || item;
            const name = String(p["Road Name"] || p.Description || p.ROAD_NAME || p.Road_Name || p.STREET || p.Location || p.SITE_LOCATION || "").toLowerCase();
            const id = String(p["Id"] || p.ID || p.Site || p.SITE || p.OBJECTID || "").toLowerCase();
            return name.includes(query) || id.includes(query);
        }).forEach(item => {
            const p = item.properties || item;
            const name = p["Road Name"] || p.Description || p.ROAD_NAME || p.Road_Name || p.STREET || p.Location || p.SITE_LOCATION;
            const id = p["Id"] || p.ID || p.Site || p.SITE || p.OBJECTID;
            const opt = document.createElement("option");
            opt.value = id;
            opt.innerText = `${name} (${id})`;
            select.appendChild(opt);
        });
    }

    // Global state for current calculation
    let currentIpswichData = null;

    function selectIpswichSite(siteId) {
        // Find the data object
        const feature = ipswichDataGlobal.find(i => {
            const p = i.properties || i;
            return String(p["Id"]) === String(siteId) || String(p["ID"]) === String(siteId) || String(p["Site"]) === String(siteId) || String(p["SITE"]) === String(siteId) || String(p.OBJECTID) === String(siteId);
        });
        
        if (!feature) return;

        currentIpswichData = feature.properties || feature;
        const p = currentIpswichData;

        // Show UI
        document.getElementById('ipswichCalcArea').style.display = 'block';
        document.getElementById('ipswichSelectedName').innerText = p["Road Name"] || p.Description || p.ROAD_NAME || p.Road_Name || p.STREET || p.Location || p.SITE_LOCATION;
        document.getElementById('ipswichAnalysisRoad').placeholder = p["Road Name"] || p.Description || p.ROAD_NAME || p.Road_Name || "Analysis Road";

        // 1. EXTRACT AADT
        // Priority: 'Average Daily Traffic...' > 'ADT' > 'AADT' > Estimate from Peak
        let aadt = p["Average Daily Traffic Adt Vehicles Per Day"] || p["ADT"] || p["AADT"] || 0;
        
        // If AADT is 0/missing, try to estimate from Peak Flows (AADT approx 10x Peak)
        if (!aadt || aadt === 0) {
            const am = p["Weekday Avg AM Peak Flow Vehicles Per Hour"] || 0;
            const pm = p["Weekday Avg PM Peak Flow Vehicles Per Hour"] || 0;
            const maxPeak = Math.max(am, pm);
            if (maxPeak > 0) aadt = maxPeak * 10; 
        }

        if (!aadt || aadt === 0) {
            let latestYear = 0;
            let latestVal = 0;
            Object.keys(p).forEach(key => {
                if (!isNaN(key) && Number(key) > 2000 && Number(key) < 2100) {
                    const val = p[key];
                    if (val && !isNaN(val) && Number(key) > latestYear) {
                        latestYear = Number(key);
                        latestVal = Number(val);
                    }
                }
            });
            if (latestVal > 0) aadt = latestVal;
        }
        
        // 2. EXTRACT OTHER METRICS
        const year = p["Year"] || p["YEAR"] || 2022; // Default if missing
        const hv = p["Percentage Commercial Vehicles"] || p["HV%"] || 0.05; // Decimal 0.05
        const growth = p["Growth Rate"] || 2.5;

        // 3. POPULATE INPUTS
        document.getElementById('ipswichBaseYear').innerText = year;
        document.getElementById('ipswichInputAADT').value = Math.round(aadt);
        
        // Handle HV formatting (JSON might be 0.04 or 4.0)
        let hvDisplay = hv;
        if (hv < 1) hvDisplay = hv * 100;
        document.getElementById('ipswichInputHV').value = hvDisplay.toFixed(1);

        document.getElementById('ipswichInputGrowth').value = growth;
        
        // Trigger Calculation
        updateIpswichAnalysis();

        // Zoom Map
        const geom = feature.geometry;
        if (geom) {
            const coords = geom.coordinates;
            ipswichMapInstance.setView([coords[1], coords[0]], 15);
        }
    }

    function updateIpswichAnalysis() {
        // Get Inputs
        const baseAADT = parseFloat(document.getElementById('ipswichInputAADT').value) || 0;
        const baseYear = parseInt(document.getElementById('ipswichBaseYear').innerText);
        const targetYear = parseInt(document.getElementById('ipswichTargetYear').value);
        const growthRate = parseFloat(document.getElementById('ipswichInputGrowth').value) / 100;
        const hvPercent = parseFloat(document.getElementById('ipswichInputHV').value) / 100;
        const capacity = parseFloat(document.getElementById('ipswichCapacity').value) || 500;
        const analysisPct = parseFloat(document.getElementById('ipswichAnalysisPct').value) / 100;

        // 1. PROJECT AADT
        const years = Math.max(0, targetYear - baseYear);
        const projectedAADT = baseAADT * Math.pow((1 + growthRate), years);
        
        // Apply "Analysis Road" Percentage (e.g. if analyzing a side road)
        const finalAADT = projectedAADT * analysisPct;

        // 2. CALCULATE PEAK FLOW (DESIGN HOURLY VOLUME - DHV)
        // Excel approximation: Peak (1-way) is approx 6.5% of AADT (based on 13% daily peak split 50/50)
        // Or derive from raw data if available. Let's use the 13% rule from the sheet unless we have specific peak data.
        // Sheet example: 194 peak (2-way) for 1518 AADT => 12.8%.
        const kFactor = 0.13; // 13% of daily traffic occurs in peak hour
        const dFactor = 0.50; // 50% directional split
        const dhvOneWay = finalAADT * kFactor * dFactor;

        // 3. QUEUE LENGTH CALCULATION
        // Formula from Excel Analysis:
        // Length = (N_cars * 7m) + (N_hv * 18m)
        // Where N is calculated based on arrival rate over time durations.
        
        const durations = [2, 5, 10, 15];
        let queueHtml = "";

        const vehPerMin = dhvOneWay / 60;
        
        durations.forEach(mins => {
            // Calculate expected arrivals in this timeframe
            // Using Math.ceil as sheet implies rounding up to whole vehicles
            const totalVeh = Math.ceil(vehPerMin * mins);
            
            const nHv = Math.ceil(totalVeh * hvPercent);
            const nCar = Math.max(0, totalVeh - nHv);
            
            // Excel Length Factors: Car=7m, HV=18m
            const length = (nCar * 7) + (nHv * 18);
            
            queueHtml += `
            <tr>
                <td>${mins} min</td>
                <td>${totalVeh}</td>
                <td style="color:${getColorForQueue(length)}">${length} m</td>
            </tr>
        `;
        });

        // 4. LOS CALCULATION
        // VCR = Volume / Capacity
        const vcr = dhvOneWay / capacity;
        let los = "A";
        let losColor = "#2ecc71"; // Green

        // Thresholds from Sheet Col 12
        if (vcr <= 0.60) { los = "A"; losColor = "#2ecc71"; }
        else if (vcr <= 0.70) { los = "B"; losColor = "#27ae60"; }
        else if (vcr <= 0.90) { los = "C"; losColor = "#f1c40f"; } // Yellow
        else if (vcr <= 0.95) { los = "D"; losColor = "#e67e22"; } // Orange
        else { los = "E/F"; losColor = "#e74c3c"; } // Red

        // 5. UPDATE DISPLAY
        document.getElementById('resAADT').innerText = Math.round(finalAADT).toLocaleString();
        document.getElementById('resPeakFlow').innerText = Math.round(dhvOneWay) + " vph";
        document.getElementById('resVCR').innerText = vcr.toFixed(2);
        
        const losEl = document.getElementById('resLOS');
        losEl.innerText = los;
        losEl.style.color = losColor;

        document.getElementById('resQueueTable').innerHTML = queueHtml;
    }

    function getColorForQueue(len) {
        if (len > 100) return "#e74c3c"; // Red warning for long queues
        if (len > 50) return "#f1c40f";  // Yellow
        return "#fff";
    }

    // --- LOGAN MODULE ---

    let loganDataGlobal = null;
    let loganLayerGroup = L.layerGroup();
    let loganMapInstance = null;

    function getLoganName(props) {
        return props.STREET_NAME || props.RoadName || props.ROAD_NAME || props.STREET || props.COUNTER_LOCATION_BETWEEN || props.COMMENTS || props.Location || "Unknown Road";
    }

    function getLoganId(props, fallbackId) {
        return props.OBJECTID || props.SiteID || props.LOCATION_ID || props.id || fallbackId || "N/A";
    }

    async function initLogan() {
        // 1. Initialize Map
        if (!loganMapInstance) {
            loganMapInstance = L.map('loganMap').setView([-27.64, 153.10], 11); // Center on Logan
            addTileLayerWithFallback(
                loganMapInstance,
                'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                { attribution: '&copy; OpenStreetMap contributors' },
                'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
                { attribution: '&copy; OpenStreetMap contributors &copy; CARTO' }
            );
        }

        // 2. Fetch Data
        if (!loganDataGlobal) {
            try {
                // Using the main branch for consistency
                const response = await fetch('https://raw.githubusercontent.com/crsanju/Cromton_Traffic_Analysis/main/logan.geojson');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: logan.geojson not found on GitHub main branch. Verify file exists and check filename case.`);
                }
                loganDataGlobal = await response.json();
                console.log('Logan data loaded from GitHub');
                
                populateLoganMap();
                populateLoganList();
            } catch (error) {
                console.error("Error loading Logan data:", error);
                alert("‚ö†Ô∏è Could not load Logan data from GitHub.\n\nPlease check:\n1. File 'logan.geojson' exists in your GitHub repo\n2. Repository is PUBLIC\n3. File is in the 'main' branch\n\nError: " + error.message);
            }
        }
        
        // Resize fix
        setTimeout(() => { loganMapInstance.invalidateSize(); }, 200);
    }

    function populateLoganMap() {
        loganLayerGroup.clearLayers();
        
        if (loganDataGlobal && loganDataGlobal.features) {
            loganDataGlobal.features.forEach(feature => {
                const props = feature.properties || {};
                const geom = feature.geometry;

                // Extract Name and ID (Flexible check for common keys)
                const name = getLoganName(props);
                const id = getLoganId(props, feature.id);
                
                // Extract Coordinates (GeoJSON is [Lon, Lat])
                if (geom && geom.coordinates) {
                    const lat = geom.coordinates[1];
                    const lon = geom.coordinates[0];

                    const marker = L.circleMarker([lat, lon], {
                        radius: 5,
                        fillColor: "#28a745", // Green for Logan
                        color: "#fff",
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8
                    });

                    marker.bindPopup(`<b>${name}</b><br>ID: ${id}<br><button onclick="selectLoganSite('${id}')">Analyze</button>`);
                    marker.on('click', () => selectLoganSite(id));
                    loganLayerGroup.addLayer(marker);
                }
            });
            loganLayerGroup.addTo(loganMapInstance);
        }
    }

    function populateLoganList() {
        const select = document.getElementById('loganSiteSelect');
        select.innerHTML = "";
        
        if (loganDataGlobal && loganDataGlobal.features) {
            // Sort alphabetically by road name
            const features = [...loganDataGlobal.features].sort((a, b) => {
                const nameA = getLoganName(a.properties || {});
                const nameB = getLoganName(b.properties || {});
                return nameA.localeCompare(nameB);
            });

            features.forEach(feature => {
                const props = feature.properties || {};
                const name = getLoganName(props);
                const id = getLoganId(props, feature.id); // Use unique ID
                
                const opt = document.createElement("option");
                opt.value = id;
                opt.innerText = `${name} (${id})`;
                select.appendChild(opt);
            });
        }
    }

    function filterLoganList() {
        const query = document.getElementById('loganSearch').value.toLowerCase();
        const select = document.getElementById('loganSiteSelect');
        select.innerHTML = "";
        
        if (loganDataGlobal && loganDataGlobal.features) {
            loganDataGlobal.features.filter(f => {
                const p = f.properties || {};
                const text = `${p.STREET_NAME || ''} ${p.RoadName || ''} ${p.ROAD_NAME || ''} ${p.STREET || ''} ${p.COUNTER_LOCATION_BETWEEN || ''} ${p.COMMENTS || ''} ${p.SUBURB || ''} ${p.OBJECTID || ''} ${p.SiteID || ''}`.toLowerCase();
                return text.includes(query);
            }).forEach(feature => {
                const props = feature.properties || {};
                const name = getLoganName(props);
                const id = getLoganId(props, feature.id);
                
                const opt = document.createElement("option");
                opt.value = id;
                opt.innerText = `${name} (${props.SUBURB || ''})`;
                select.appendChild(opt);
            });
        }
    }

    // Store current selection
    let currentLoganFeature = null;

    function selectLoganSite(siteId) {
        // Find feature by ID (converting to string to be safe)
        if (!loganDataGlobal || !loganDataGlobal.features) return;

        currentLoganFeature = loganDataGlobal.features.find(feature => {
            const props = feature.properties || {};
            const featureId = getLoganId(props, feature.id);
            return String(featureId) === String(siteId) || 
                String(props.SiteID || '') === String(siteId);
        });
        
        if (!currentLoganFeature) return;

        const props = currentLoganFeature.properties || {};

        // Show Calc Area
        document.getElementById('loganCalcArea').style.display = 'block';

        // Extract Name
        const name = getLoganName(props);
        document.getElementById('loganSelectedName').innerText = name;
        document.getElementById('loganAnalysisRoad').placeholder = name || "Analysis Road";

        // Extract Traffic Data (prefer AADT; fallback to AAWT or VOL1+VOL2)
        let aadt = props.AADT ?? props.ADT ?? props.AAWT ?? props.Volume;
        if (aadt == null || isNaN(aadt)) {
            const vol1 = Number(props.VOL1 || 0);
            const vol2 = Number(props.VOL2 || 0);
            aadt = (isNaN(vol1) ? 0 : vol1) + (isNaN(vol2) ? 0 : vol2);
        }

        let year = props.YEAR || props.Year || 2020; // Default if missing

        // Try to parse year from date fields if present
        if (props.AADT_DATE || props.AAWT_DATE || props.COUNT_DATE || props.COMP_DATE) {
            const d = new Date(props.AADT_DATE || props.AAWT_DATE || props.COUNT_DATE || props.COMP_DATE);
            if (!isNaN(d.getFullYear())) year = d.getFullYear();
        }

        // Default Growth Rate (2.5% standard or use property if exists)
        let growth = props.GROWTH_RATE || 2.5; 
        if (growth < 1) growth = growth * 100;

        // Heavy vehicle percent if available; default to 5.0
        let hv = props.HV_PCT ?? props.HV ?? props.OV_PCENT ?? 5.0;
        if (hv < 1) hv = hv * 100;

        // Update inputs
        document.getElementById('loganBaseYear').innerText = year;
        document.getElementById('loganInputAADT').value = Math.round(Number(aadt) || 0);
        document.getElementById('loganInputGrowth').value = Number(growth).toFixed(1);
        document.getElementById('loganInputHV').value = Number(hv).toFixed(1);

        // Zoom Map
        const coords = currentLoganFeature.geometry.coordinates;
        if (coords) {
            loganMapInstance.setView([coords[1], coords[0]], 15);
        }

        updateLoganAnalysis();
    }

    function updateLoganAnalysis() {
        // Get Inputs
        const baseAADT = parseFloat(document.getElementById('loganInputAADT').value) || 0;
        const baseYear = parseInt(document.getElementById('loganBaseYear').innerText);
        const targetYear = parseInt(document.getElementById('loganTargetYear').value);
        const growthRate = parseFloat(document.getElementById('loganInputGrowth').value) / 100;
        const hvPercent = parseFloat(document.getElementById('loganInputHV').value) / 100;
        const capacity = parseFloat(document.getElementById('loganCapacity').value) || 500;
        const analysisPct = parseFloat(document.getElementById('loganAnalysisPct').value) / 100;

        // 1. PROJECT AADT
        const years = Math.max(0, targetYear - baseYear);
        const projectedAADT = baseAADT * Math.pow((1 + growthRate), years);
        const finalAADT = projectedAADT * analysisPct;

        // 2. CALCULATE PEAK FLOW (DESIGN HOURLY VOLUME - DHV)
        const kFactor = 0.13;
        const dFactor = 0.50;
        const dhvOneWay = finalAADT * kFactor * dFactor;

        // 3. QUEUE LENGTH CALCULATION
        const durations = [2, 5, 10, 15];
        let queueHtml = "";

        const vehPerMin = dhvOneWay / 60;

        durations.forEach(mins => {
            const totalVeh = Math.ceil(vehPerMin * mins);
            const nHv = Math.ceil(totalVeh * hvPercent);
            const nCar = Math.max(0, totalVeh - nHv);
            const length = (nCar * 7) + (nHv * 18);

            queueHtml += `
            <tr>
                <td>${mins} min</td>
                <td>${totalVeh}</td>
                <td style="color:${getColorForQueue(length)}">${length} m</td>
            </tr>
        `;
        });

        // 4. LOS CALCULATION
        const vcr = dhvOneWay / capacity;
        let los = "A";
        let losColor = "#2ecc71";

        if (vcr <= 0.60) { los = "A"; losColor = "#2ecc71"; }
        else if (vcr <= 0.70) { los = "B"; losColor = "#27ae60"; }
        else if (vcr <= 0.90) { los = "C"; losColor = "#f1c40f"; }
        else if (vcr <= 0.95) { los = "D"; losColor = "#e67e22"; }
        else { los = "E/F"; losColor = "#e74c3c"; }

        // 5. UPDATE DISPLAY
        document.getElementById('loganResAADT').innerText = Math.round(finalAADT).toLocaleString();
        document.getElementById('loganResPeakFlow').innerText = Math.round(dhvOneWay) + " vph";
        document.getElementById('loganResVCR').innerText = vcr.toFixed(2);

        const losEl = document.getElementById('loganResLOS');
        losEl.innerText = los;
        losEl.style.color = losColor;

        document.getElementById('loganResQueueTable').innerHTML = queueHtml;
    }
</script>
</body>
</html>
